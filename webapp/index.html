<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Words to Review</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --tg-theme-bg-color: #ffffff;
            --tg-theme-text-color: #000000;
            --tg-theme-hint-color: #999999;
            --tg-theme-link-color: #2678b6;
            --tg-theme-button-color: #50a8eb;
            --tg-theme-button-text-color: #ffffff;
            --tg-theme-secondary-bg-color: #f0f0f0;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background-color: var(--tg-theme-bg-color);
            color: var(--tg-theme-text-color);
            padding: 12px;
            padding-bottom: 80px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
        }

        .word-count {
            font-size: 14px;
            color: var(--tg-theme-hint-color);
        }

        /* Burger Menu */
        .burger-btn {
            width: 36px;
            height: 36px;
            background: var(--tg-theme-secondary-bg-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
            padding: 8px;
        }

        .burger-btn span {
            display: block;
            width: 18px;
            height: 2px;
            background: var(--tg-theme-text-color);
            border-radius: 1px;
            transition: all 0.3s;
        }

        .burger-btn.open span:nth-child(1) {
            transform: rotate(45deg) translate(4px, 4px);
        }

        .burger-btn.open span:nth-child(2) {
            opacity: 0;
        }

        .burger-btn.open span:nth-child(3) {
            transform: rotate(-45deg) translate(4px, -4px);
        }

        .back-btn {
            background: var(--tg-theme-secondary-bg-color);
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            color: var(--tg-theme-text-color);
            cursor: pointer;
            transition: all 0.2s;
        }

        .back-btn:active {
            opacity: 0.7;
        }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .menu-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        .side-menu {
            position: fixed;
            top: 0;
            left: -280px;
            width: 280px;
            height: 100%;
            background: var(--tg-theme-bg-color);
            z-index: 201;
            transition: left 0.3s;
            padding: 20px;
            overflow-y: auto;
        }

        .side-menu.open {
            left: 0;
        }

        .menu-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--tg-theme-secondary-bg-color);
        }

        .menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 12px;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
            margin-bottom: 4px;
        }

        .menu-item:active {
            background: var(--tg-theme-secondary-bg-color);
        }

        /* Transcript segment styles */
        .transcript-segment {
            padding: 4px 0;
            transition: background 0.2s ease, padding 0.2s ease, margin 0.2s ease;
        }

        .transcript-segment.active {
            background: rgba(0,123,255,0.15);
            border-radius: 4px;
            padding: 8px;
            margin: 4px -8px;
        }

        .menu-item.active {
            background: var(--tg-theme-button-color);
            color: var(--tg-theme-button-text-color);
        }

        .menu-item-icon {
            font-size: 20px;
        }

        .menu-item-text {
            font-size: 16px;
            font-weight: 500;
        }

        /* Pages */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        /* Home Page Styles */
        .home-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
            max-width: 500px;
            margin: 0 auto;
            padding: 20px 0;
        }

        .home-title {
            font-size: 24px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 12px;
            color: var(--tg-theme-text-color);
        }

        .home-subtitle {
            font-size: 15px;
            text-align: center;
            color: var(--tg-theme-hint-color);
            margin-bottom: 20px;
        }

        .home-menu-btn {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 20px 24px;
            background: var(--tg-theme-secondary-bg-color);
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            font-size: 16px;
        }

        .home-menu-btn:active {
            transform: scale(0.98);
            background: color-mix(in srgb, var(--tg-theme-button-color) 20%, var(--tg-theme-secondary-bg-color));
        }

        .home-menu-icon {
            font-size: 32px;
            min-width: 40px;
            text-align: center;
        }

        .home-menu-content {
            flex: 1;
        }

        .home-menu-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--tg-theme-text-color);
            margin-bottom: 4px;
        }

        .home-menu-desc {
            font-size: 14px;
            color: var(--tg-theme-hint-color);
        }

        /* Digest Page Styles */
        .digest-card {
            background: var(--tg-theme-secondary-bg-color);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .digest-date {
            font-size: 13px;
            color: var(--tg-theme-hint-color);
            margin-bottom: 8px;
        }

        .digest-section-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .digest-text {
            font-size: 15px;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .digest-text b {
            color: var(--tg-theme-button-color);
        }

        /* Clickable words in digest */
        .digest-word {
            cursor: pointer;
            border-radius: 3px;
            transition: background 0.15s;
        }

        .digest-word:hover {
            background: color-mix(in srgb, var(--tg-theme-button-color) 20%, transparent);
        }

        .digest-word:active {
            background: color-mix(in srgb, var(--tg-theme-button-color) 30%, transparent);
        }

        /* Podcasts Page Styles */
        .podcast-card {
            background: var(--tg-theme-secondary-bg-color);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .podcast-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .podcast-date {
            font-size: 14px;
            font-weight: 600;
            color: var(--tg-theme-text-color);
        }

        .podcast-duration {
            font-size: 13px;
            color: var(--tg-theme-hint-color);
        }

        .podcast-title {
            font-size: 15px;
            color: var(--tg-theme-text-color);
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .podcast-description {
            font-size: 13px;
            color: var(--tg-theme-hint-color);
            line-height: 1.5;
            margin-bottom: 12px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .podcast-description.expanded {
            max-height: 500px;
        }

        .podcast-description p {
            margin: 0 0 8px 0;
        }

        .podcast-show-description-btn {
            background: transparent;
            border: none;
            color: var(--tg-theme-link-color);
            font-size: 13px;
            cursor: pointer;
            padding: 4px 0;
            margin-bottom: 12px;
            text-decoration: underline;
        }

        .podcast-play-btn {
            width: 100%;
            padding: 12px;
            background: var(--tg-theme-button-color);
            color: var(--tg-theme-button-text-color);
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .podcast-play-btn:active {
            transform: scale(0.98);
        }

        .podcast-play-btn.playing {
            background: var(--tg-theme-hint-color);
        }

        /* Audio player controls */
        .podcast-player {
            margin-top: 12px;
            padding: 12px;
            background: rgba(0,0,0,0.05);
            border-radius: 8px;
        }

        .podcast-progress-container {
            position: relative;
            width: 100%;
            height: 6px;
            background: rgba(0,0,0,0.1);
            border-radius: 3px;
            margin-bottom: 8px;
            cursor: pointer;
        }

        .podcast-progress-bar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: var(--tg-theme-button-color);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .podcast-time {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--tg-theme-hint-color);
        }

        .podcast-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            margin-top: 8px;
        }

        .podcast-control-btn {
            background: var(--tg-theme-button-color);
            color: var(--tg-theme-button-text-color);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
        }

        .podcast-control-btn:active {
            transform: scale(0.95);
        }

        /* Word translation popup */
        .word-translation-popup {
            position: fixed;
            bottom: 80px;
            left: 12px;
            right: 12px;
            background: var(--tg-theme-secondary-bg-color);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 150;
            display: none;
            animation: slideUp 0.2s ease;
        }

        .word-translation-popup.visible {
            display: block;
        }

        .word-translation-popup .word-original {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--tg-theme-button-color);
        }

        .word-translation-popup .word-translated {
            font-size: 16px;
            color: var(--tg-theme-text-color);
        }

        .word-translation-popup .word-transcript {
            font-size: 13px;
            color: var(--tg-theme-hint-color);
            margin-top: 4px;
        }

        .word-translation-popup .word-pos {
            font-size: 12px;
            color: var(--tg-theme-button-color);
            font-style: italic;
            margin-top: 4px;
        }

        .word-translation-popup .word-example {
            font-size: 13px;
            color: var(--tg-theme-hint-color);
            margin-top: 8px;
            border-top: 1px solid var(--tg-theme-hint-color);
            padding-top: 8px;
        }

        .word-translation-popup .word-source {
            font-size: 11px;
            color: var(--tg-theme-hint-color);
            margin-top: 6px;
            opacity: 0.6;
        }

        .word-translation-popup .word-loading {
            color: var(--tg-theme-hint-color);
            font-style: italic;
        }

        .word-translation-popup .close-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--tg-theme-hint-color);
            padding: 4px;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Audio Mini Player */
        .audio-player {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 16px;
            padding: 12px;
            background: var(--tg-theme-bg-color);
            border-radius: 12px;
        }

        .player-btn {
            width: 44px;
            height: 44px;
            min-width: 44px;
            border-radius: 50%;
            background: var(--tg-theme-button-color);
            color: var(--tg-theme-button-text-color);
            border: none;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .player-btn:active {
            transform: scale(0.95);
        }

        .player-btn.playing {
            background: #e74c3c;
        }

        .player-btn.loading {
            background: var(--tg-theme-hint-color);
        }

        .player-progress-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .player-progress-bar {
            width: 100%;
            height: 6px;
            background: var(--tg-theme-secondary-bg-color);
            border-radius: 3px;
            overflow: hidden;
            cursor: pointer;
        }

        .player-progress-fill {
            height: 100%;
            background: var(--tg-theme-button-color);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .player-time {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--tg-theme-hint-color);
        }

        .player-status {
            font-size: 12px;
            color: var(--tg-theme-hint-color);
            text-align: center;
        }

        /* Sticky header with tabs and autoplay controls */
        .sticky-header {
            position: sticky;
            top: 0;
            z-index: 100;
            background: var(--tg-theme-bg-color);
            padding-bottom: 8px;
            margin: -12px -12px 12px -12px;
            padding: 12px 12px 8px 12px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0;
            margin-bottom: 0;
            border-radius: 10px;
            overflow: hidden;
            background: var(--tg-theme-secondary-bg-color);
        }

        .tab-btn {
            flex: 1;
            padding: 12px 16px;
            background: transparent;
            color: var(--tg-theme-hint-color);
            border: none;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-btn.active {
            background: var(--tg-theme-button-color);
            color: var(--tg-theme-button-text-color);
        }

        .tab-btn:active {
            opacity: 0.8;
        }

        /* Autoplay controls for random tab */
        .autoplay-controls {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .autoplay-btn {
            flex: 1;
            padding: 12px 16px;
            background: var(--tg-theme-secondary-bg-color);
            color: var(--tg-theme-text-color);
            border: 2px solid transparent;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .autoplay-btn.active {
            background: var(--tg-theme-button-color);
            color: var(--tg-theme-button-text-color);
            border-color: var(--tg-theme-button-color);
        }

        .autoplay-btn:active {
            transform: scale(0.98);
        }

        .autoplay-btn.load-batch-btn {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }

        .autoplay-btn.load-batch-btn:disabled {
            background: #6c757d;
            border-color: #6c757d;
            cursor: not-allowed;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            color: var(--tg-theme-hint-color);
        }

        .error {
            text-align: center;
            padding: 40px 20px;
            color: #e74c3c;
        }

        .word-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .word-card {
            background: var(--tg-theme-secondary-bg-color);
            border-radius: 12px;
            padding: 16px;
            transition: transform 0.1s ease;
        }

        .word-card:active {
            transform: scale(0.98);
        }

        .word-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 6px;
        }

        .word-text {
            font-size: 20px;
            font-weight: 600;
            color: var(--tg-theme-text-color);
        }

        .audio-btn {
            background: var(--tg-theme-button-color);
            color: var(--tg-theme-button-text-color);
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s;
        }

        .audio-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .audio-btn:active:not(:disabled) {
            opacity: 0.7;
        }

        .audio-btn.playing {
            animation: pulse 0.5s infinite alternate;
        }

        /* Repeat button */
        .repeat-btn {
            background: #ff9500;
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .repeat-btn:active {
            transform: scale(0.95);
            opacity: 0.8;
        }

        .repeat-btn.sent {
            background: #34c759;
        }

        .repeat-btn.sending {
            opacity: 0.6;
        }

        /* Hidden translation */
        .translate.hidden {
            filter: blur(8px);
            cursor: pointer;
            user-select: none;
            transition: filter 0.3s ease;
        }

        .translate.hidden:hover {
            filter: blur(4px);
        }

        .word-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .word-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .word-number {
            font-size: 14px;
            color: var(--tg-theme-hint-color);
            min-width: 24px;
        }

        /* Quiz styles */
        .quiz-container {
            padding: 16px 0;
        }

        .quiz-card {
            background: var(--tg-theme-secondary-bg-color);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .quiz-progress {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            font-size: 14px;
            color: var(--tg-theme-hint-color);
        }

        .quiz-progress-bar {
            flex: 1;
            height: 4px;
            background: var(--tg-theme-bg-color);
            border-radius: 2px;
            margin: 0 12px;
            overflow: hidden;
        }

        .quiz-progress-fill {
            height: 100%;
            background: var(--tg-theme-button-color);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .quiz-question {
            text-align: center;
            margin-bottom: 24px;
        }

        .quiz-question-label {
            font-size: 14px;
            color: var(--tg-theme-hint-color);
            margin-bottom: 12px;
        }

        .quiz-question-text {
            font-size: 24px;
            font-weight: 600;
            line-height: 1.3;
        }

        .quiz-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .quiz-option {
            background: var(--tg-theme-bg-color);
            border: 2px solid transparent;
            border-radius: 12px;
            padding: 16px 12px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .quiz-option:active {
            transform: scale(0.98);
        }

        .quiz-option.selected {
            border-color: var(--tg-theme-button-color);
            background: color-mix(in srgb, var(--tg-theme-button-color) 15%, var(--tg-theme-bg-color));
        }

        .quiz-option.correct {
            border-color: #34c759;
            background: color-mix(in srgb, #34c759 15%, var(--tg-theme-bg-color));
        }

        .quiz-option.wrong {
            border-color: #ff3b30;
            background: color-mix(in srgb, #ff3b30 15%, var(--tg-theme-bg-color));
        }

        .quiz-option.disabled {
            pointer-events: none;
            opacity: 0.7;
        }

        .quiz-result {
            text-align: center;
            padding: 16px;
            border-radius: 12px;
            margin-top: 16px;
            font-weight: 500;
        }

        .quiz-result.correct {
            background: color-mix(in srgb, #34c759 15%, var(--tg-theme-bg-color));
            color: #34c759;
        }

        .quiz-result.wrong {
            background: color-mix(in srgb, #ff3b30 15%, var(--tg-theme-bg-color));
            color: #ff3b30;
        }

        .quiz-next-btn {
            width: 100%;
            padding: 16px;
            margin-top: 16px;
            background: var(--tg-theme-button-color);
            color: var(--tg-theme-button-text-color);
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quiz-next-btn:active {
            transform: scale(0.98);
            opacity: 0.9;
        }

        .quiz-stats {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--tg-theme-secondary-bg-color);
        }

        .quiz-stat {
            text-align: center;
        }

        .quiz-stat-value {
            font-size: 24px;
            font-weight: 600;
        }

        .quiz-stat-value.correct {
            color: #34c759;
        }

        .quiz-stat-value.wrong {
            color: #ff3b30;
        }

        .quiz-stat-label {
            font-size: 12px;
            color: var(--tg-theme-hint-color);
        }

        .quiz-complete {
            text-align: center;
            padding: 40px 20px;
        }

        .quiz-complete-icon {
            font-size: 64px;
            margin-bottom: 16px;
        }

        .quiz-complete-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .quiz-complete-subtitle {
            font-size: 16px;
            color: var(--tg-theme-hint-color);
            margin-bottom: 24px;
        }

        .quiz-audio-btn {
            background: var(--tg-theme-secondary-bg-color);
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            font-size: 20px;
            cursor: pointer;
            margin-top: 12px;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }

        .transcript {
            font-size: 14px;
            color: var(--tg-theme-hint-color);
            margin-bottom: 8px;
            font-style: italic;
        }

        .translate {
            font-size: 16px;
            color: var(--tg-theme-text-color);
            opacity: 0.85;
        }

        .example {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(0,0,0,0.1);
            font-size: 14px;
            color: var(--tg-theme-hint-color);
            font-style: italic;
        }

        .refresh-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--tg-theme-button-color);
            color: var(--tg-theme-button-text-color);
            border: none;
            border-radius: 50%;
            width: 56px;
            height: 56px;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .refresh-btn:active {
            transform: scale(0.95);
        }

        .refresh-btn.spinning {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Pagination */
        .pagination {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 16px 0;
            margin-top: 12px;
        }

        .pagination-btn {
            background: var(--tg-theme-secondary-bg-color);
            border: none;
            border-radius: 8px;
            padding: 10px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
            color: var(--tg-theme-text-color);
        }

        .pagination-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .pagination-btn:not(:disabled):active {
            background: var(--tg-theme-button-color);
            color: var(--tg-theme-button-text-color);
        }

        .pagination-info {
            font-size: 14px;
            color: var(--tg-theme-hint-color);
            min-width: 80px;
            text-align: center;
        }

        .word-card.highlighted {
            border: 2px solid var(--tg-theme-button-color);
            background: color-mix(in srgb, var(--tg-theme-button-color) 10%, var(--tg-theme-secondary-bg-color));
        }

        /* Date groups */
        .date-groups {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .date-group {
            background: var(--tg-theme-secondary-bg-color);
            border-radius: 12px;
            overflow: hidden;
        }

        .date-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .date-group-header:active {
            background: rgba(0,0,0,0.05);
        }

        .date-group-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .date-group-date {
            font-size: 18px;
            font-weight: 600;
            color: var(--tg-theme-text-color);
        }

        .date-group-count {
            font-size: 14px;
            color: var(--tg-theme-hint-color);
        }

        .date-group-arrow {
            font-size: 20px;
            color: var(--tg-theme-hint-color);
            transition: transform 0.2s;
        }

        .date-group.expanded .date-group-arrow {
            transform: rotate(90deg);
        }

        .date-group-content {
            display: none;
            padding: 0 16px 16px 16px;
        }

        .date-group.expanded .date-group-content {
            display: block;
        }

        .group-autoplay-controls {
            display: none; /* Hidden - using sticky header instead */
        }

        .group-autoplay-btn {
            flex: 1;
            padding: 10px 12px;
            background: var(--tg-theme-bg-color);
            color: var(--tg-theme-text-color);
            border: 1px solid var(--tg-theme-hint-color);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .group-autoplay-btn.active {
            background: var(--tg-theme-button-color);
            color: var(--tg-theme-button-text-color);
            border-color: var(--tg-theme-button-color);
        }

        .group-autoplay-btn:active {
            transform: scale(0.98);
        }

        .group-word-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .group-word-card {
            background: var(--tg-theme-bg-color);
            border-radius: 10px;
            padding: 12px;
        }

        .group-word-card.highlighted {
            border: 2px solid var(--tg-theme-button-color);
            background: color-mix(in srgb, var(--tg-theme-button-color) 10%, var(--tg-theme-bg-color));
        }
    </style>
</head>
<body>
    <!-- Burger Menu Overlay -->
    <div class="menu-overlay" id="menuOverlay" data-action="close-menu"></div>

    <!-- Side Menu -->
    <div class="side-menu" id="sideMenu">
        <div class="menu-header">AI Jarvis</div>
        <div class="menu-item active" data-action="navigate" data-page="home">
            <span class="menu-item-icon">üè†</span>
            <span class="menu-item-text">Home</span>
        </div>
        <div class="menu-item" data-action="navigate" data-page="words">
            <span class="menu-item-icon">üìö</span>
            <span class="menu-item-text">Vocabulary Review</span>
        </div>
        <div class="menu-item" data-action="navigate" data-page="digest">
            <span class="menu-item-icon">üì∞</span>
            <span class="menu-item-text">AI Digest</span>
        </div>
        <div class="menu-item" data-action="navigate" data-page="dictionary">
            <span class="menu-item-icon">üìñ</span>
            <span class="menu-item-text">Dictionary</span>
        </div>
        <div class="menu-item" data-action="navigate" data-page="quiz">
            <span class="menu-item-icon">üß†</span>
            <span class="menu-item-text">Quiz</span>
        </div>
        <div class="menu-item" data-action="navigate" data-page="podcasts">
            <span class="menu-item-icon">üéß</span>
            <span class="menu-item-text">Plain English Podcasts</span>
        </div>
    </div>

    <!-- Home Page -->
    <div class="page active" id="homePage">
        <div class="header">
            <div class="header-left">
                <button class="burger-btn" id="burgerBtnHome" data-action="toggle-menu">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <h1>AI Jarvis</h1>
            </div>
        </div>

        <div class="home-container">
            <h2 class="home-title">Welcome to AI Jarvis</h2>
            <p class="home-subtitle">Your English Learning Companion</p>

            <button class="home-menu-btn" data-action="navigate" data-page="words">
                <div class="home-menu-icon">üìö</div>
                <div class="home-menu-content">
                    <div class="home-menu-title">Vocabulary Review</div>
                    <div class="home-menu-desc">Review and practice your vocabulary words</div>
                </div>
            </button>

            <button class="home-menu-btn" data-action="navigate" data-page="digest">
                <div class="home-menu-icon">üì∞</div>
                <div class="home-menu-content">
                    <div class="home-menu-title">AI Digest</div>
                    <div class="home-menu-desc">Daily English news and articles</div>
                </div>
            </button>

            <button class="home-menu-btn" data-action="navigate" data-page="dictionary">
                <div class="home-menu-icon">üìñ</div>
                <div class="home-menu-content">
                    <div class="home-menu-title">Dictionary</div>
                    <div class="home-menu-desc">Browse all your vocabulary words</div>
                </div>
            </button>

            <button class="home-menu-btn" data-action="navigate" data-page="quiz">
                <div class="home-menu-icon">üß†</div>
                <div class="home-menu-content">
                    <div class="home-menu-title">Quiz</div>
                    <div class="home-menu-desc">Test your knowledge with quizzes</div>
                </div>
            </button>

            <button class="home-menu-btn" data-action="navigate" data-page="podcasts">
                <div class="home-menu-icon">üéß</div>
                <div class="home-menu-content">
                    <div class="home-menu-title">Plain English Podcasts</div>
                    <div class="home-menu-desc">Listen to Plain English podcasts</div>
                </div>
            </button>
        </div>
    </div>

    <!-- Words Page -->
    <div class="page" id="wordsPage">
        <div class="header">
            <div class="header-left">
                <button class="burger-btn" id="burgerBtn" data-action="toggle-menu">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <h1>Words to Review</h1>
            </div>
            <span class="word-count" id="wordCount"></span>
        </div>

        <div class="sticky-header">
            <div class="tabs">
                <button class="tab-btn active" data-tab="grouped" data-action="tab">–ü–æ –¥–∞—Ç–∞–º</button>
                <button class="tab-btn" data-tab="random" data-action="tab">–°–ª—É—á–∞–π–Ω—ã–µ</button>
            </div>

            <div class="autoplay-controls" id="randomAutoplayControls" style="display: none;">
                <button class="autoplay-btn" id="autoplayEnglishBtn"
                        data-action="random-autoplay" data-mode="english">
                    ‚ñ∂ English Only
                </button>
                <button class="autoplay-btn" id="autoplayBothBtn"
                        data-action="random-autoplay" data-mode="both">
                    ‚ñ∂ Eng + Rus
                </button>
            </div>

            <div class="autoplay-controls" id="groupAutoplayControls" style="display: none;">
                <button class="autoplay-btn" id="groupAutoplayEnglishBtn"
                        data-action="group-autoplay" data-mode="english">
                    ‚ñ∂ English Only
                </button>
                <button class="autoplay-btn" id="groupAutoplayBothBtn"
                        data-action="group-autoplay" data-mode="both">
                    ‚ñ∂ Eng + Rus
                </button>
            </div>
        </div>

        <div id="groupedPagination" class="pagination" style="display: none;">
            <button class="pagination-btn" id="prevPageBtn" data-action="prev-page">‚Äπ –ü—Ä–µ–¥—ã–¥—É—â–∞—è</button>
            <span class="pagination-info" id="paginationInfo">–°—Ç—Ä–∞–Ω–∏—Ü–∞ 1 –∏–∑ 1</span>
            <button class="pagination-btn" id="nextPageBtn" data-action="next-page">–°–ª–µ–¥—É—é—â–∞—è ‚Ä∫</button>
        </div>

        <div id="content">
            <div class="loading">Loading words...</div>
        </div>

        <button class="refresh-btn" id="refreshBtn" onclick="resetAndLoad()">&#x21bb;</button>
    </div>

    <!-- Digest Page -->
    <div class="page" id="digestPage">
        <div class="header">
            <div class="header-left">
                <button class="burger-btn" data-action="toggle-menu">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <h1>AI Digest</h1>
            </div>
        </div>

        <div id="digestContent">
            <div class="loading">Loading digests...</div>
        </div>

        <button class="refresh-btn" id="digestRefreshBtn" data-action="refresh-digest">&#x21bb;</button>
    </div>

    <!-- Dictionary Page -->
    <div class="page" id="dictionaryPage">
        <div class="header">
            <div class="header-left">
                <button class="burger-btn" data-action="toggle-menu">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <h1>Dictionary</h1>
            </div>
            <span class="word-count" id="dictWordCount"></span>
        </div>

        <div class="sticky-header">
            <div class="autoplay-controls" id="dictAutoplayControls">
                <button class="autoplay-btn" id="dictAutoplayEnglishBtn"
                        data-action="dict-autoplay" data-mode="english">
                    ‚ñ∂ English Only
                </button>
                <button class="autoplay-btn" id="dictAutoplayBothBtn"
                        data-action="dict-autoplay" data-mode="both">
                    ‚ñ∂ Eng + Rus
                </button>
                <button class="autoplay-btn load-batch-btn" id="loadNewBatchBtn"
                        data-action="load-new-batch">
                    Load New Batch
                </button>
            </div>
        </div>

        <div id="dictionaryContent">
            <div class="loading">Loading dictionary...</div>
        </div>

        <button class="refresh-btn" id="dictRefreshBtn" data-action="refresh-dictionary">&#x21bb;</button>
    </div>

    <!-- Quiz Page -->
    <div class="page" id="quizPage">
        <div class="header">
            <div class="header-left">
                <button class="burger-btn" data-action="toggle-menu">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <h1>Quiz</h1>
            </div>
            <span class="word-count" id="quizWordCount"></span>
        </div>

        <div class="sticky-header">
            <div class="tabs">
                <button class="tab-btn active" data-tab="activeRecall" data-action="quiz-tab">Active Recall</button>
                <button class="tab-btn" data-tab="scheduled" data-action="quiz-tab">Scheduled</button>
            </div>
        </div>

        <div id="quizContent">
            <div class="loading">Select a tab to start quiz...</div>
        </div>

        <button class="refresh-btn" id="quizRefreshBtn" data-action="refresh-quiz">&#x21bb;</button>
    </div>

    <!-- Podcasts Page -->
    <div class="page" id="podcastsPage">
        <div class="header">
            <div class="header-left">
                <button class="burger-btn" data-action="toggle-menu">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <h1>Plain English Podcasts</h1>
            </div>
            <span class="word-count" id="podcastCount"></span>
        </div>

        <div id="podcastsContent">
            <div class="loading">Loading podcasts...</div>
        </div>

        <button class="refresh-btn" id="podcastsRefreshBtn" data-action="refresh-podcasts">&#x21bb;</button>
    </div>

    <!-- Podcast Player Page -->
    <div class="page" id="podcastPlayerPage">
        <div class="header">
            <div class="header-left">
                <button class="back-btn" data-action="back-to-podcasts">
                    ‚Üê Back
                </button>
                <h1 id="playerPodcastTitle">Podcast</h1>
            </div>
        </div>

        <div id="podcastPlayerContent" style="padding: 16px;">
            <!-- Transcript container -->
            <div id="playerTranscript" style="background: rgba(0,0,0,0.05); border-radius: 12px; padding: 16px; height: 60vh; overflow-y: auto; margin-bottom: 20px;">
                <div style="text-align: center; color: var(--tg-theme-hint-color);">
                    Loading transcript...
                </div>
            </div>

            <!-- Player controls -->
            <div class="podcast-player" id="playerControls">
                <div class="podcast-progress-container" data-action="seek-player" id="playerProgress">
                    <div class="podcast-progress-bar" id="playerProgressBar" style="width: 0%"></div>
                </div>
                <div class="podcast-time">
                    <span id="playerCurrentTime">0:00</span>
                    <span id="playerTotalTime">0:00</span>
                </div>
                <div class="podcast-controls">
                    <button class="podcast-control-btn" data-action="player-rewind">
                        ‚è™
                    </button>
                    <button class="podcast-control-btn" data-action="player-play-pause" id="playerPlayPauseBtn">
                        ‚è∏
                    </button>
                    <button class="podcast-control-btn" data-action="player-forward">
                        ‚è©
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_URL = 'https://n8n.aimediaflow.net/webhook/words-repeat';
        const DIGEST_API_URL = 'https://n8n.aimediaflow.net/webhook/get-digests';
        const DICTIONARY_API_URL = 'https://n8n.aimediaflow.net/webhook/words-all';
        const MARK_REPEAT_API_URL = 'https://n8n.aimediaflow.net/webhook/mark-repeat';
        const QUIZ_API_URL = 'https://n8n.aimediaflow.net/webhook/quiz-words';
        const UPDATE_WORD_STAGE_API_URL = 'https://n8n.aimediaflow.net/webhook/update-word-stage';
        const MARK_NEW_BATCH_API_URL = 'https://n8n.aimediaflow.net/webhook/mark-new-batch';
        const PODCASTS_API_URL = 'https://n8n.aimediaflow.net/webhook/voa-podcasts';
        const AUDIO_PROXY_URL = 'https://n8n.aimediaflow.net/webhook/audio-proxy';
        const TRANSCRIBE_API_URL = 'https://n8n.aimediaflow.net/webhook/transcribe-podcast';
        const CHECK_TRANSCRIPTS_API_URL = 'https://n8n.aimediaflow.net/webhook/check-transcripts';

        // State
        let dateGroups = [];
        let randomWords = [];
        let totalWords = 0;
        let isLoading = false;
        let expandedGroup = null; // date string of expanded group
        let activeGroupDate = null; // date of group with active autoplay
        let currentTab = 'grouped'; // 'grouped' or 'random'
        let currentPage = 'home'; // 'home', 'words', 'digest', 'dictionary', 'quiz'
        let podcastTranscripts = {}; // cache of available transcripts

        // Pagination state
        let currentPageNum = 1;
        let totalPages = 1;
        let daysPerPage = 7;

        // Random tab autoplay state
        let randomAutoplayMode = null;
        let randomAutoplayIndex = 0;
        // Separate state for each random autoplay mode
        let randomAutoplayIndexEnglish = 0;
        let randomAutoplayIndexBoth = 0;

        // Digest state
        let currentDigest = null;
        let digestAudio = null;
        let currentDigestPlayingBtn = null;

        // Dictionary state
        let dictionaryWords = [];
        let dictAutoplayMode = null;
        let dictAutoplayIndex = 0;
        // Separate state for each autoplay mode
        let dictAutoplayIndexEnglish = 0;
        let dictAutoplayIndexBoth = 0;
        let revealedTranslations = new Set(); // Track which translations are revealed
        let markedAsRepeat = new Set(); // Track word IDs marked as repeat (exclude from new batch)

        // Quiz state
        let quizWords = []; // Target words for quiz

        // Podcasts state
        let podcastEpisodes = [];
        let currentPodcastAudio = null;
        let currentPlayingPodcast = null; // index of playing podcast
        let expandedPodcastDescriptions = new Set(); // track expanded descriptions
        let podcastTranscriptSegments = {}; // store parsed segments with timestamps
        let transcribingPodcasts = new Set(); // track which podcasts are being transcribed
        let autoScrollEnabled = {}; // track auto-scroll state per podcast
        let userScrollTimeout = null; // timeout for detecting user scroll
        let wakeLock = null; // Screen wake lock
        let quizDistractors = []; // All words for distractors
        let quizCurrentTab = 'activeRecall'; // 'activeRecall' or 'scheduled'
        let quizCurrentIndex = 0;
        let quizOptions = []; // Current question options
        let quizAnswered = false;
        let quizCorrectCount = 0;
        let quizWrongCount = 0;

        // Initialize Telegram WebApp
        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();

            // Apply Telegram theme
            document.documentElement.style.setProperty('--tg-theme-bg-color', tg.themeParams.bg_color || '#ffffff');
            document.documentElement.style.setProperty('--tg-theme-text-color', tg.themeParams.text_color || '#000000');
            document.documentElement.style.setProperty('--tg-theme-hint-color', tg.themeParams.hint_color || '#999999');
            document.documentElement.style.setProperty('--tg-theme-link-color', tg.themeParams.link_color || '#2678b6');
            document.documentElement.style.setProperty('--tg-theme-button-color', tg.themeParams.button_color || '#50a8eb');
            document.documentElement.style.setProperty('--tg-theme-button-text-color', tg.themeParams.button_text_color || '#ffffff');
            document.documentElement.style.setProperty('--tg-theme-secondary-bg-color', tg.themeParams.secondary_bg_color || '#f0f0f0');
        }

        let currentPlayingBtn = null;
        let autoplayMode = null; // null, 'english', 'both'
        let autoplayIndex = 0;
        // Separate state for each group autoplay mode per date
        let groupAutoplayStates = {}; // { "2024-01-15": { english: 5, both: 3 } }
        let autoplayTimeout = null;
        let isAutoplayPaused = false;

        // Single reusable Audio object for Telegram compatibility
        let sharedAudio = new Audio();
        sharedAudio.volume = 1.0;
        let audioUnlocked = false;

        function resetAndLoad() {
            dateGroups = [];
            randomWords = [];
            totalWords = 0;
            expandedGroup = null;
            currentPageNum = 1;
            stopAutoplay();
            stopRandomAutoplay();
            document.getElementById('groupAutoplayControls').style.display = 'none';
            if (currentTab === 'random') {
                loadRandomWords();
            } else {
                loadWords(1);
            }
        }

        function switchTab(tab) {
            if (currentTab === tab) return;

            stopAutoplay();
            stopRandomAutoplay();
            currentTab = tab;
            expandedGroup = null;

            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.getAttribute('data-tab') === tab);
            });

            const randomControls = document.getElementById('randomAutoplayControls');
            const groupControls = document.getElementById('groupAutoplayControls');
            const pagination = document.getElementById('groupedPagination');

            if (tab === 'grouped') {
                randomControls.style.display = 'none';
                groupControls.style.display = 'none';
                pagination.style.display = totalPages > 1 ? 'flex' : 'none';
                if (dateGroups.length > 0) {
                    renderGroups();
                    document.getElementById('wordCount').textContent = totalWords;
                } else {
                    loadWords();
                }
            } else {
                randomControls.style.display = 'flex';
                groupControls.style.display = 'none';
                pagination.style.display = 'none';
                loadRandomWords();
            }
        }

        async function loadWords(page = 1) {
            if (isLoading) return;
            isLoading = true;

            const content = document.getElementById('content');
            const refreshBtn = document.getElementById('refreshBtn');
            const wordCount = document.getElementById('wordCount');
            const pagination = document.getElementById('groupedPagination');

            refreshBtn.classList.add('spinning');
            content.innerHTML = '<div class="loading">Loading words...</div>';
            // Reset group autoplay states when loading new page
            groupAutoplayStates = {};

            try {
                const url = `${API_URL}?mode=grouped&page=${page}&daysPerPage=${daysPerPage}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to fetch');

                const data = await response.json();
                dateGroups = data.dateGroups || [];
                totalWords = data.total || 0;

                // Update pagination state
                if (data.pagination) {
                    currentPageNum = data.pagination.page;
                    totalPages = data.pagination.totalPages;
                    updatePaginationUI();
                    pagination.style.display = 'flex';
                } else {
                    pagination.style.display = 'none';
                }

                wordCount.textContent = totalWords;

                if (dateGroups.length === 0) {
                    content.innerHTML = '<div class="loading">No words to review</div>';
                    pagination.style.display = 'none';
                    return;
                }

                renderGroups();

            } catch (error) {
                console.error('Error:', error);
                content.innerHTML = '<div class="error">Failed to load words.<br>Please try again.</div>';
                document.getElementById('groupedPagination').style.display = 'none';
            } finally {
                isLoading = false;
                refreshBtn.classList.remove('spinning');
            }
        }

        function updatePaginationUI() {
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            const info = document.getElementById('paginationInfo');

            prevBtn.disabled = currentPageNum <= 1;
            nextBtn.disabled = currentPageNum >= totalPages;
            info.textContent = `–ù–µ–¥–µ–ª—è ${currentPageNum} –∏–∑ ${totalPages}`;
        }

        async function loadRandomWords() {
            if (isLoading) return;
            isLoading = true;

            const content = document.getElementById('content');
            const refreshBtn = document.getElementById('refreshBtn');
            const wordCount = document.getElementById('wordCount');

            refreshBtn.classList.add('spinning');
            content.innerHTML = '<div class="loading">Loading random words...</div>';
            // Reset autoplay indices when loading new random words
            randomAutoplayIndexEnglish = 0;
            randomAutoplayIndexBoth = 0;

            try {
                const response = await fetch(API_URL + '?mode=random');
                if (!response.ok) throw new Error('Failed to fetch');

                const data = await response.json();
                randomWords = data.words || [];

                wordCount.textContent = randomWords.length;

                if (randomWords.length === 0) {
                    content.innerHTML = '<div class="loading">No words to review</div>';
                    return;
                }

                renderRandomWords();

            } catch (error) {
                console.error('Error:', error);
                content.innerHTML = '<div class="error">Failed to load words.<br>Please try again.</div>';
            } finally {
                isLoading = false;
                refreshBtn.classList.remove('spinning');
            }
        }

        function renderRandomWords() {
            const content = document.getElementById('content');

            // Update sticky autoplay buttons state
            const englishBtn = document.getElementById('autoplayEnglishBtn');
            const bothBtn = document.getElementById('autoplayBothBtn');
            englishBtn.classList.toggle('active', randomAutoplayMode === 'english');
            bothBtn.classList.toggle('active', randomAutoplayMode === 'both');

            let html = '<div class="word-list">';

            randomWords.forEach((word, index) => {
                html += renderRandomWordCard(word, index);
            });

            html += '</div>';
            content.innerHTML = html;
        }

        function renderRandomWordCard(word, index) {
            const audioUrl = word.audio || '';
            const isHighlighted = randomAutoplayMode && randomAutoplayIndex === index;

            // Build transcript line with meta info
            const transcriptParts = [];
            if (word.transcript && word.transcript !== 'None') {
                transcriptParts.push(`/${word.transcript}/`);
            }
            if (word.partOfSpeech) {
                transcriptParts.push(word.partOfSpeech);
            }
            if (word.level) {
                transcriptParts.push(word.level);
            }
            if (word.trainDate) {
                transcriptParts.push(word.trainDate);
            }
            const transcriptLine = transcriptParts.join(' ¬∑ ');

            return `
                <div class="word-card ${isHighlighted ? 'highlighted' : ''}" data-index="${index}">
                    <div class="word-header">
                        <span class="word-text">${escapeHtml(word.word)}</span>
                        <button class="audio-btn" id="random-audio-btn-${index}"
                                data-action="play-random" data-url="${escapeHtml(audioUrl)}" data-widx="${index}">
                            &#x1F50A;
                        </button>
                    </div>
                    ${transcriptLine ? `<div class="transcript">${escapeHtml(transcriptLine)}</div>` : ''}
                    <div class="translate">${escapeHtml(word.translate)}</div>
                    ${word.example ? `<div class="example">"${escapeHtml(word.example)}"</div>` : ''}
                </div>
            `;
        }

        function renderGroups() {
            const content = document.getElementById('content');

            let html = '<div class="date-groups">';

            dateGroups.forEach((group, groupIndex) => {
                const isExpanded = expandedGroup === group.date;
                const formattedDate = formatDate(group.date);

                html += `
                    <div class="date-group ${isExpanded ? 'expanded' : ''}" data-date="${group.date}" data-index="${groupIndex}">
                        <div class="date-group-header" data-action="toggle" data-gidx="${groupIndex}">
                            <div class="date-group-info">
                                <span class="date-group-date">${formattedDate}</span>
                                <span class="date-group-count">${group.count} —Å–ª–æ–≤</span>
                            </div>
                            <span class="date-group-arrow">‚ñ∂</span>
                        </div>
                        <div class="date-group-content">
                            ${isExpanded ? renderGroupContent(group, groupIndex) : ''}
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            content.innerHTML = html;
        }

        function formatDate(dateStr) {
            if (!dateStr || dateStr === 'unknown') return '–ë–µ–∑ –¥–∞—Ç—ã';
            const date = new Date(dateStr);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);

            if (dateStr === today.toISOString().split('T')[0]) {
                return '–°–µ–≥–æ–¥–Ω—è';
            } else if (dateStr === yesterday.toISOString().split('T')[0]) {
                return '–í—á–µ—Ä–∞';
            }

            return date.toLocaleDateString('ru-RU', {
                day: 'numeric',
                month: 'long',
                year: date.getFullYear() !== today.getFullYear() ? 'numeric' : undefined
            });
        }

        function toggleGroup(date) {
            const groupControls = document.getElementById('groupAutoplayControls');

            if (expandedGroup === date) {
                expandedGroup = null;
                stopAutoplay();
                groupControls.style.display = 'none';
            } else {
                stopAutoplay();
                expandedGroup = date;
                groupControls.style.display = 'flex';
                updateGroupAutoplayButtons();
            }
            renderGroups();
        }

        function updateGroupAutoplayButtons() {
            const englishBtn = document.getElementById('groupAutoplayEnglishBtn');
            const bothBtn = document.getElementById('groupAutoplayBothBtn');
            const isActiveGroup = activeGroupDate === expandedGroup;

            englishBtn.classList.toggle('active', isActiveGroup && autoplayMode === 'english');
            bothBtn.classList.toggle('active', isActiveGroup && autoplayMode === 'both');
        }

        function renderGroupContent(group, groupIndex) {
            let html = '<div class="group-word-list">';

            group.words.forEach((word, index) => {
                html += renderWordCard(word, groupIndex, index);
            });

            html += '</div>';
            return html;
        }

        function renderWordCard(word, groupIndex, index) {
            const audioUrl = word.audio || '';
            const group = dateGroups[groupIndex];
            const isHighlighted = activeGroupDate === group.date && autoplayIndex === index;

            // Build transcript line with meta info
            const transcriptParts = [];
            if (word.transcript && word.transcript !== 'None') {
                transcriptParts.push(`/${word.transcript}/`);
            }
            if (word.partOfSpeech) {
                transcriptParts.push(word.partOfSpeech);
            }
            if (word.level) {
                transcriptParts.push(word.level);
            }
            if (word.trainDate) {
                transcriptParts.push(word.trainDate);
            }
            const transcriptLine = transcriptParts.join(' ¬∑ ');

            return `
                <div class="group-word-card ${isHighlighted ? 'highlighted' : ''}" data-index="${index}">
                    <div class="word-header">
                        <span class="word-text">${escapeHtml(word.word)}</span>
                        <button class="audio-btn" id="audio-btn-${groupIndex}-${index}"
                                data-action="play" data-url="${escapeHtml(audioUrl)}" data-gidx="${groupIndex}" data-widx="${index}">
                            &#x1F50A;
                        </button>
                    </div>
                    ${transcriptLine ? `<div class="transcript">${escapeHtml(transcriptLine)}</div>` : ''}
                    <div class="translate">${escapeHtml(word.translate)}</div>
                    ${word.example ? `<div class="example">"${escapeHtml(word.example)}"</div>` : ''}
                </div>
            `;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        let currentAudio = null;

        function playAudio(url, groupDate, wordIndex) {
            if (!url) return;

            // Stop current audio if playing
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
                if (currentPlayingBtn) {
                    currentPlayingBtn.classList.remove('playing');
                }
            }

            // Haptic feedback
            if (tg?.HapticFeedback) {
                tg.HapticFeedback.impactOccurred('light');
            }

            const groupIndex = dateGroups.findIndex(g => g.date === groupDate);
            const btn = document.getElementById(`audio-btn-${groupIndex}-${wordIndex}`);
            currentPlayingBtn = btn;
            if (btn) btn.classList.add('playing');

            currentAudio = new Audio(url);
            currentAudio.volume = 1.0;

            currentAudio.onended = () => {
                if (btn) btn.classList.remove('playing');
                currentPlayingBtn = null;
            };

            currentAudio.onerror = (err) => {
                console.error('Audio playback failed:', err);
                if (btn) btn.classList.remove('playing');
                currentPlayingBtn = null;
                if (tg?.HapticFeedback) {
                    tg.HapticFeedback.notificationOccurred('error');
                }
            };

            currentAudio.play().catch(err => {
                console.error('Audio play error:', err);
                if (btn) btn.classList.remove('playing');
                currentPlayingBtn = null;
            });
        }

        // Unlock audio for Telegram - must be called from user gesture
        function unlockAudio() {
            if (audioUnlocked) return Promise.resolve();

            return new Promise((resolve) => {
                // Play silent audio to unlock
                sharedAudio.src = 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA/+M4wAAAAAAAAAAAAEluZm8AAAAPAAAAAwAAAbAAqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV////////////////////////////////////////////AAAAAExhdmM1OC4xMwAAAAAAAAAAAAAAACQAAAAAAAAAAQGwBPBbAAAAAAD/4xjEAAAANIAAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxDsAAADSAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';
                sharedAudio.volume = 0.01;
                sharedAudio.play().then(() => {
                    audioUnlocked = true;
                    sharedAudio.pause();
                    sharedAudio.volume = 1;
                    resolve();
                }).catch(() => {
                    resolve(); // Continue anyway
                });
            });
        }

        // Autoplay functions for groups
        async function toggleGroupAutoplay(groupDate, mode) {
            if (activeGroupDate === groupDate && autoplayMode === mode) {
                // Pause: save current index for this mode and date
                if (!groupAutoplayStates[groupDate]) {
                    groupAutoplayStates[groupDate] = { english: 0, both: 0 };
                }
                groupAutoplayStates[groupDate][mode] = autoplayIndex;
                stopAutoplay();
                updateGroupContent(groupDate);
            } else {
                // Start autoplay - first unlock audio from this user gesture
                await unlockAudio();
                stopAutoplay();
                activeGroupDate = groupDate;
                autoplayMode = mode;

                // Restore index for this mode and date
                if (!groupAutoplayStates[groupDate]) {
                    groupAutoplayStates[groupDate] = { english: 0, both: 0 };
                }
                autoplayIndex = groupAutoplayStates[groupDate][mode] || 0;

                // Ensure index is valid
                const group = dateGroups.find(g => g.date === groupDate);
                if (group && autoplayIndex >= group.words.length) {
                    autoplayIndex = 0;
                }

                updateGroupContent(groupDate);
                playNextWord();
            }
        }

        function updateGroupContent(groupDate) {
            const groupIndex = dateGroups.findIndex(g => g.date === groupDate);
            if (groupIndex === -1) return;

            const group = dateGroups[groupIndex];
            const groupEl = document.querySelector(`.date-group[data-index="${groupIndex}"]`);
            if (!groupEl) return;

            const contentEl = groupEl.querySelector('.date-group-content');
            if (contentEl) {
                contentEl.innerHTML = renderGroupContent(group, groupIndex);
            }
        }

        function stopAutoplay() {
            const prevGroupDate = activeGroupDate;
            autoplayMode = null;
            activeGroupDate = null;
            isAutoplayPaused = false;
            if (autoplayTimeout) {
                clearTimeout(autoplayTimeout);
                autoplayTimeout = null;
            }
            // Stop shared audio
            sharedAudio.pause();
            sharedAudio.onended = null;
            sharedAudio.onerror = null;

            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            if (window.speechSynthesis && window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }
            // Remove highlights
            document.querySelectorAll('.group-word-card.highlighted').forEach(el => {
                el.classList.remove('highlighted');
            });
            // Update buttons
            if (prevGroupDate) {
                updateGroupContent(prevGroupDate);
            }

            // Clear media session and release wake lock
            clearMediaSession();
            releaseWakeLock();
        }

        function highlightWord(groupDate, index) {
            document.querySelectorAll('.group-word-card.highlighted').forEach(el => {
                el.classList.remove('highlighted');
            });
            const groupIndex = dateGroups.findIndex(g => g.date === groupDate);
            if (groupIndex === -1) return;

            const groupEl = document.querySelector(`.date-group[data-index="${groupIndex}"]`);
            if (!groupEl) return;

            const cards = groupEl.querySelectorAll('.group-word-card');
            if (cards[index]) {
                cards[index].classList.add('highlighted');
                cards[index].scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function playNextWord() {
            if (!autoplayMode || !activeGroupDate) {
                stopAutoplay();
                return;
            }

            const group = dateGroups.find(g => g.date === activeGroupDate);
            if (!group) {
                stopAutoplay();
                return;
            }

            // Reached end of list, stop and save position
            if (autoplayIndex >= group.words.length) {
                if (!groupAutoplayStates[activeGroupDate]) {
                    groupAutoplayStates[activeGroupDate] = { english: 0, both: 0 };
                }
                groupAutoplayStates[activeGroupDate][autoplayMode] = autoplayIndex;
                stopAutoplay();
                return;
            }

            const word = group.words[autoplayIndex];
            highlightWord(activeGroupDate, autoplayIndex);

            // Setup media session and wake lock on first word
            if (autoplayIndex === 0 || (groupAutoplayStates[activeGroupDate] && autoplayIndex === groupAutoplayStates[activeGroupDate][autoplayMode])) {
                setupVocabularyMediaSession(word.word, autoplayMode);
                requestWakeLock();
            }

            if (autoplayMode === 'english') {
                // English only: word -> 1s pause -> next word
                playWordAudioAutoplay(word.audio, () => {
                    autoplayTimeout = setTimeout(() => {
                        autoplayIndex++;
                        if (groupAutoplayStates[activeGroupDate]) {
                            groupAutoplayStates[activeGroupDate].english = autoplayIndex;
                        }
                        playNextWord();
                    }, 1000);
                });
            } else if (autoplayMode === 'both') {
                // English + Russian: word -> 1s -> translation -> 2s -> next word
                playWordAudioAutoplay(word.audio, () => {
                    autoplayTimeout = setTimeout(() => {
                        speakRussian(word.word, () => {
                            autoplayTimeout = setTimeout(() => {
                                autoplayIndex++;
                                if (groupAutoplayStates[activeGroupDate]) {
                                    groupAutoplayStates[activeGroupDate].both = autoplayIndex;
                                }
                                playNextWord();
                            }, 2000);
                        });
                    }, 1000);
                });
            }
        }

        function playWordAudioAutoplay(url, onComplete) {
            if (!url || !autoplayMode) {
                if (onComplete) onComplete();
                return;
            }

            // Use shared audio object for Telegram compatibility
            sharedAudio.pause();
            sharedAudio.onended = null;
            sharedAudio.onerror = null;

            sharedAudio.src = url;
            sharedAudio.currentTime = 0;
            sharedAudio.volume = 1.0;

            sharedAudio.onended = () => {
                if (onComplete) onComplete();
            };

            sharedAudio.onerror = () => {
                if (onComplete) onComplete();
            };

            sharedAudio.play().catch(() => {
                if (onComplete) onComplete();
            });
        }

        // Play Russian translation audio from pre-generated files
        function speakRussian(englishWord, onComplete) {
            if (!englishWord) {
                if (onComplete) onComplete();
                return;
            }

            const wordLower = englishWord.toLowerCase().replace(/ /g, '_');
            const audioUrl = `https://vocab.aimediaflow.net/audio-ru/${encodeURIComponent(wordLower)}.mp3`;

            // Use shared audio for playback
            sharedAudio.pause();
            sharedAudio.onended = null;
            sharedAudio.onerror = null;

            sharedAudio.src = audioUrl;
            sharedAudio.currentTime = 0;
            sharedAudio.volume = 1.0;

            sharedAudio.onended = () => {
                if (onComplete) onComplete();
            };

            sharedAudio.onerror = () => {
                console.warn('Russian audio not found:', audioUrl);
                if (onComplete) onComplete();
            };

            sharedAudio.play().catch(() => {
                if (onComplete) onComplete();
            });
        }

        // Random words autoplay
        async function toggleRandomAutoplay(mode) {
            if (randomAutoplayMode === mode) {
                // Pause: save current index for this mode
                if (mode === 'english') {
                    randomAutoplayIndexEnglish = randomAutoplayIndex;
                } else if (mode === 'both') {
                    randomAutoplayIndexBoth = randomAutoplayIndex;
                }
                stopRandomAutoplay();
                renderRandomWords(); // Update UI to show paused state
            } else {
                await unlockAudio();
                stopRandomAutoplay();
                randomAutoplayMode = mode;

                // Restore index for this mode
                if (mode === 'english') {
                    randomAutoplayIndex = randomAutoplayIndexEnglish;
                } else if (mode === 'both') {
                    randomAutoplayIndex = randomAutoplayIndexBoth;
                }

                // Ensure index is valid
                if (randomAutoplayIndex >= randomWords.length) {
                    randomAutoplayIndex = 0;
                }

                renderRandomWords();
                playNextRandomWord();
            }
        }

        function stopRandomAutoplay() {
            randomAutoplayMode = null;
            if (autoplayTimeout) {
                clearTimeout(autoplayTimeout);
                autoplayTimeout = null;
            }
            sharedAudio.pause();
            sharedAudio.onended = null;
            sharedAudio.onerror = null;

            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            if (window.speechSynthesis && window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }

            // Clear media session and release wake lock
            clearMediaSession();
            releaseWakeLock();

            document.querySelectorAll('.word-card.highlighted').forEach(el => {
                el.classList.remove('highlighted');
            });
        }

        function highlightRandomWord(index) {
            document.querySelectorAll('.word-card.highlighted').forEach(el => {
                el.classList.remove('highlighted');
            });
            const cards = document.querySelectorAll('.word-card');
            if (cards[index]) {
                cards[index].classList.add('highlighted');
                cards[index].scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function playNextRandomWord() {
            if (!randomAutoplayMode || randomWords.length === 0) {
                stopRandomAutoplay();
                return;
            }

            if (randomAutoplayIndex >= randomWords.length) {
                // Reached end of list, stop and save position
                if (randomAutoplayMode === 'english') {
                    randomAutoplayIndexEnglish = randomAutoplayIndex;
                } else if (randomAutoplayMode === 'both') {
                    randomAutoplayIndexBoth = randomAutoplayIndex;
                }
                stopRandomAutoplay();
                return;
            }

            const word = randomWords[randomAutoplayIndex];
            highlightRandomWord(randomAutoplayIndex);

            // Setup media session and wake lock on first word
            if (randomAutoplayIndex === 0 || randomAutoplayIndex === randomAutoplayIndexEnglish || randomAutoplayIndex === randomAutoplayIndexBoth) {
                setupVocabularyMediaSession(word.word, randomAutoplayMode);
                requestWakeLock();
            }

            if (randomAutoplayMode === 'english') {
                playRandomWordAudio(word.audio, () => {
                    autoplayTimeout = setTimeout(() => {
                        randomAutoplayIndex++;
                        randomAutoplayIndexEnglish = randomAutoplayIndex;
                        playNextRandomWord();
                    }, 1000);
                });
            } else if (randomAutoplayMode === 'both') {
                playRandomWordAudio(word.audio, () => {
                    autoplayTimeout = setTimeout(() => {
                        speakRussian(word.word, () => {
                            autoplayTimeout = setTimeout(() => {
                                randomAutoplayIndex++;
                                randomAutoplayIndexBoth = randomAutoplayIndex;
                                playNextRandomWord();
                            }, 2000);
                        });
                    }, 1000);
                });
            }
        }

        function playRandomWordAudio(url, onComplete) {
            if (!url || !randomAutoplayMode) {
                if (onComplete) onComplete();
                return;
            }

            sharedAudio.pause();
            sharedAudio.onended = null;
            sharedAudio.onerror = null;

            sharedAudio.src = url;
            sharedAudio.currentTime = 0;
            sharedAudio.volume = 1.0;

            sharedAudio.onended = () => {
                if (onComplete) onComplete();
            };

            sharedAudio.onerror = () => {
                if (onComplete) onComplete();
            };

            sharedAudio.play().catch(() => {
                if (onComplete) onComplete();
            });
        }

        function playRandomAudioSingle(url, wordIndex) {
            if (!url) return;

            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
                if (currentPlayingBtn) {
                    currentPlayingBtn.classList.remove('playing');
                }
            }

            if (tg?.HapticFeedback) {
                tg.HapticFeedback.impactOccurred('light');
            }

            const btn = document.getElementById(`random-audio-btn-${wordIndex}`);
            currentPlayingBtn = btn;
            if (btn) btn.classList.add('playing');

            currentAudio = new Audio(url);
            currentAudio.volume = 1.0;

            currentAudio.onended = () => {
                if (btn) btn.classList.remove('playing');
                currentPlayingBtn = null;
            };

            currentAudio.onerror = () => {
                if (btn) btn.classList.remove('playing');
                currentPlayingBtn = null;
            };

            currentAudio.play().catch(() => {
                if (btn) btn.classList.remove('playing');
                currentPlayingBtn = null;
            });
        }

        // Handle action from element - use numeric indices instead of date strings
        function handleAction(target, event) {
            if (!target) return false;

            const action = target.getAttribute('data-action');
            if (!action) return false;

            const gidx = target.getAttribute('data-gidx');

            if (action === 'tab') {
                const tab = target.getAttribute('data-tab');
                if (tab) {
                    switchTab(tab);
                }
                return true;
            } else if (action === 'toggle') {
                const groupIndex = parseInt(gidx);
                const group = dateGroups[groupIndex];
                if (group) {
                    toggleGroup(group.date);
                }
                return true;
            } else if (action === 'autoplay') {
                const groupIndex = parseInt(gidx);
                const group = dateGroups[groupIndex];
                const mode = target.getAttribute('data-mode');
                if (group) {
                    toggleGroupAutoplay(group.date, mode);
                }
                return true;
            } else if (action === 'play') {
                const url = target.getAttribute('data-url');
                const groupIndex = parseInt(target.getAttribute('data-gidx'));
                const wordIndex = parseInt(target.getAttribute('data-widx'));
                const group = dateGroups[groupIndex];
                if (group) {
                    playAudio(url, group.date, wordIndex);
                }
                return true;
            } else if (action === 'random-autoplay') {
                const mode = target.getAttribute('data-mode');
                toggleRandomAutoplay(mode);
                return true;
            } else if (action === 'group-autoplay') {
                const mode = target.getAttribute('data-mode');
                if (expandedGroup) {
                    toggleGroupAutoplay(expandedGroup, mode);
                    updateGroupAutoplayButtons();
                }
                return true;
            } else if (action === 'play-random') {
                const url = target.getAttribute('data-url');
                const wordIndex = parseInt(target.getAttribute('data-widx'));
                playRandomAudioSingle(url, wordIndex);
                return true;
            } else if (action === 'toggle-menu') {
                toggleMenu();
                return true;
            } else if (action === 'close-menu') {
                closeMenu();
                return true;
            } else if (action === 'navigate') {
                const page = target.getAttribute('data-page');
                navigateToPage(page);
                return true;
            } else if (action === 'prev-page') {
                if (currentPageNum > 1) {
                    loadWords(currentPageNum - 1);
                }
                return true;
            } else if (action === 'next-page') {
                if (currentPageNum < totalPages) {
                    loadWords(currentPageNum + 1);
                }
                return true;
            } else if (action === 'refresh-digest') {
                loadDigests();
                return true;
            } else if (action === 'player-toggle') {
                toggleDigestPlayer();
                return true;
            } else if (action === 'player-seek') {
                seekDigestAudio(event);
                return true;
            } else if (action === 'refresh-dictionary') {
                loadDictionary();
                return true;
            } else if (action === 'dict-autoplay') {
                const mode = target.getAttribute('data-mode');
                toggleDictAutoplay(mode);
                return true;
            } else if (action === 'play-dict') {
                const url = target.getAttribute('data-url');
                const wordIndex = parseInt(target.getAttribute('data-widx'));
                playDictAudioSingle(url, wordIndex);
                return true;
            } else if (action === 'reveal-translate') {
                const wordIndex = parseInt(target.getAttribute('data-widx'));
                revealTranslation(wordIndex, target);
                return true;
            } else if (action === 'mark-repeat') {
                const wordId = target.getAttribute('data-word-id');
                const wordIndex = parseInt(target.getAttribute('data-widx'));
                markWordForRepeat(wordId, wordIndex);
                return true;
            } else if (action === 'quiz-tab') {
                const tab = target.getAttribute('data-tab');
                switchQuizTab(tab);
                return true;
            } else if (action === 'refresh-quiz') {
                loadQuiz();
                return true;
            } else if (action === 'quiz-answer') {
                const optionIndex = parseInt(target.getAttribute('data-option'));
                handleQuizAnswer(optionIndex);
                return true;
            } else if (action === 'quiz-next') {
                nextQuizQuestion();
                return true;
            } else if (action === 'quiz-restart') {
                restartQuiz();
                return true;
            } else if (action === 'quiz-start') {
                startQuiz();
                return true;
            } else if (action === 'quiz-audio') {
                playQuizAudio();
                return true;
            } else if (action === 'translate-word') {
                const word = target.textContent.trim();
                if (word) translateWord(word);
                return true;
            } else if (action === 'close-word-popup') {
                closeWordPopup();
                return true;
            } else if (action === 'load-new-batch') {
                loadNewBatch();
                return true;
            } else if (action === 'refresh-podcasts') {
                loadPodcasts();
                return true;
            } else if (action === 'play-podcast') {
                const index = parseInt(target.getAttribute('data-index'));
                const url = target.getAttribute('data-url');
                openPodcastPlayer(index, url);
                return true;
            } else if (action === 'rewind-podcast') {
                const index = parseInt(target.getAttribute('data-index'));
                if (currentPlayingPodcast === index) {
                    rewindPodcast(15);
                }
                return true;
            } else if (action === 'forward-podcast') {
                const index = parseInt(target.getAttribute('data-index'));
                if (currentPlayingPodcast === index) {
                    forwardPodcast(15);
                }
                return true;
            } else if (action === 'seek-podcast') {
                const index = parseInt(target.getAttribute('data-index'));
                seekPodcast(index, target, event);
                return true;
            } else if (action === 'toggle-podcast-description') {
                const index = parseInt(target.getAttribute('data-index'));
                togglePodcastDescription(index);
                return true;
            } else if (action === 'transcribe-podcast') {
                const index = parseInt(target.getAttribute('data-index'));
                const url = target.getAttribute('data-url');
                transcribePodcast(index, url);
                return true;
            } else if (action === 'back-to-podcasts') {
                closePodcastPlayer();
                return true;
            } else if (action === 'player-play-pause') {
                togglePlayerPlayPause();
                return true;
            } else if (action === 'player-rewind') {
                rewindPodcast(15);
                return true;
            } else if (action === 'player-forward') {
                forwardPodcast(15);
                return true;
            } else if (action === 'seek-player') {
                seekPlayerPodcast(target, event);
                return true;
            }
            return false;
        }

        // Menu functions
        function toggleMenu() {
            const menu = document.getElementById('sideMenu');
            const overlay = document.getElementById('menuOverlay');
            const burgerBtns = document.querySelectorAll('.burger-btn');

            menu.classList.toggle('open');
            overlay.classList.toggle('open');
            burgerBtns.forEach(btn => btn.classList.toggle('open'));
        }

        function closeMenu() {
            const menu = document.getElementById('sideMenu');
            const overlay = document.getElementById('menuOverlay');
            const burgerBtns = document.querySelectorAll('.burger-btn');

            menu.classList.remove('open');
            overlay.classList.remove('open');
            burgerBtns.forEach(btn => btn.classList.remove('open'));
        }

        function navigateToPage(page) {
            if (currentPage === page) {
                closeMenu();
                return;
            }

            // Stop any playing audio
            stopAutoplay();
            stopRandomAutoplay();
            stopDigestAudio();
            stopDictAutoplay();
            stopPodcast();

            // Update menu items
            document.querySelectorAll('.menu-item').forEach(item => {
                item.classList.toggle('active', item.getAttribute('data-page') === page);
            });

            // Switch pages
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));

            if (page === 'home') {
                document.getElementById('homePage').classList.add('active');
            } else if (page === 'words') {
                document.getElementById('wordsPage').classList.add('active');
                // Always reload words to get fresh data (e.g., after marking words for repeat)
                loadWords();
            } else if (page === 'digest') {
                document.getElementById('digestPage').classList.add('active');
                // Always reload digest to get fresh data
                loadDigests();
            } else if (page === 'dictionary') {
                document.getElementById('dictionaryPage').classList.add('active');
                // Always reload dictionary to get fresh data
                loadDictionary();
            } else if (page === 'quiz') {
                document.getElementById('quizPage').classList.add('active');
                // Always reload quiz to get fresh data
                loadQuiz();
            } else if (page === 'podcasts') {
                document.getElementById('podcastsPage').classList.add('active');
                // Always reload podcasts to get fresh data
                loadPodcasts();
            }

            currentPage = page;
            closeMenu();
        }

        // Digest functions
        async function loadDigests() {
            const content = document.getElementById('digestContent');
            const refreshBtn = document.getElementById('digestRefreshBtn');

            refreshBtn.classList.add('spinning');
            content.innerHTML = '<div class="loading">Loading digest...</div>';

            try {
                const response = await fetch(DIGEST_API_URL);
                if (!response.ok) throw new Error('Failed to fetch');

                const data = await response.json();
                currentDigest = data.digest || null;

                if (!currentDigest) {
                    content.innerHTML = '<div class="loading">No digest available</div>';
                    return;
                }

                renderDigest();

            } catch (error) {
                console.error('Error:', error);
                content.innerHTML = '<div class="error">Failed to load digest.<br>Please try again.</div>';
            } finally {
                refreshBtn.classList.remove('spinning');
            }
        }

        // Make text clickable by words
        function makeWordsClickable(text) {
            if (!text) return '';
            // Split by word boundaries, keeping punctuation attached
            return text.replace(/([a-zA-Z']+)/g, '<span class="digest-word" data-action="translate-word">$1</span>');
        }

        function renderDigest() {
            const content = document.getElementById('digestContent');
            const digest = currentDigest;

            if (!digest) {
                content.innerHTML = '<div class="loading">No digest available</div>';
                return;
            }

            const date = new Date(digest.createdAt);
            const formattedDate = date.toLocaleDateString('ru-RU', {
                day: 'numeric',
                month: 'long',
                hour: '2-digit',
                minute: '2-digit'
            });

            // Parse digest text - separate vocabulary from main text
            const digestMarker = '---START_OF_DIGEST---';
            let vocabSection = '';
            let mainTextEn = digest.text || '';
            let mainTextRu = digest.russianText || '';

            if (mainTextEn.includes(digestMarker)) {
                const parts = mainTextEn.split(digestMarker);
                vocabSection = parts[0].trim();
                mainTextEn = parts[1]?.trim() || '';
            }

            // Same for Russian
            if (mainTextRu.includes(digestMarker)) {
                const parts = mainTextRu.split(digestMarker);
                mainTextRu = parts[1]?.trim() || '';
            }

            // Format vocabulary section (preserve line breaks)
            const vocabHtml = vocabSection ? escapeHtml(vocabSection).replace(/\n/g, '<br>') : '';

            // Make English words clickable for translation
            const englishHtml = makeWordsClickable(escapeHtml(mainTextEn));

            let html = `
                <div class="digest-card">
                    <div class="digest-date">${formattedDate}</div>
                    <div class="digest-section-title">üá¨üáß English <span style="font-size: 12px; font-weight: normal; color: var(--tg-theme-hint-color);">(tap word for translation)</span></div>
                    ${vocabHtml ? `<div class="digest-text">${vocabHtml}</div><hr style="margin: 12px 0; border: none; border-top: 1px solid var(--tg-theme-hint-color); opacity: 0.3;">` : ''}
                    <div class="digest-text">${englishHtml}</div>
                    <div class="audio-player" id="digestPlayer">
                        <button class="player-btn" id="playerBtn" data-action="player-toggle">
                            ‚ñ∂
                        </button>
                        <div class="player-progress-container">
                            <div class="player-progress-bar" id="playerProgressBar" data-action="player-seek">
                                <div class="player-progress-fill" id="playerProgressFill"></div>
                            </div>
                            <div class="player-time">
                                <span id="playerCurrentTime">0:00</span>
                                <span id="playerDuration">0:00</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="digest-card">
                    <div class="digest-section-title">üá∑üá∫ –†—É—Å—Å–∫–∏–π</div>
                    <div class="digest-text">${escapeHtml(mainTextRu || '–ü–µ—Ä–µ–≤–æ–¥ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω')}</div>
                </div>
            `;

            content.innerHTML = html;

            // Add word translation popup to body if not exists
            if (!document.getElementById('wordTranslationPopup')) {
                const popup = document.createElement('div');
                popup.id = 'wordTranslationPopup';
                popup.className = 'word-translation-popup';
                popup.innerHTML = `
                    <button class="close-btn" data-action="close-word-popup">√ó</button>
                    <div class="word-original" id="wordOriginal"></div>
                    <div class="word-transcript" id="wordTranscript"></div>
                    <div class="word-pos" id="wordPartOfSpeech"></div>
                    <div class="word-translated" id="wordTranslated"></div>
                    <div class="word-example" id="wordExample"></div>
                    <div class="word-source" id="wordSource"></div>
                `;
                document.body.appendChild(popup);
            }
        }

        // Word translation using n8n workflow (MongoDB lookup + Gemini AI fallback)
        async function translateWord(word) {
            const popup = document.getElementById('wordTranslationPopup');
            const originalEl = document.getElementById('wordOriginal');
            const translatedEl = document.getElementById('wordTranslated');
            const transcriptEl = document.getElementById('wordTranscript');
            const posEl = document.getElementById('wordPartOfSpeech');
            const exampleEl = document.getElementById('wordExample');
            const sourceEl = document.getElementById('wordSource');

            if (!popup || !originalEl || !translatedEl) return;

            // Show popup with loading state
            originalEl.textContent = word;
            translatedEl.innerHTML = '<span class="word-loading">–ü–µ—Ä–µ–≤–æ–¥–∏–º...</span>';
            if (transcriptEl) transcriptEl.textContent = '';
            if (posEl) posEl.textContent = '';
            if (exampleEl) exampleEl.textContent = '';
            if (sourceEl) sourceEl.textContent = '';
            popup.classList.add('visible');

            // Haptic feedback
            if (tg?.HapticFeedback) {
                tg.HapticFeedback.impactOccurred('light');
            }

            try {
                const response = await fetch(`https://n8n.aimediaflow.net/webhook/translate-word?word=${encodeURIComponent(word)}`);
                const data = await response.json();

                if (data.translate) {
                    translatedEl.textContent = data.translate;
                    if (transcriptEl && data.transcript) transcriptEl.textContent = `[${data.transcript}]`;
                    if (posEl && data.partOfSpeech) posEl.textContent = data.partOfSpeech;
                    if (exampleEl && data.example) exampleEl.textContent = data.example;
                    if (sourceEl && data.source) sourceEl.textContent = data.source === 'database' ? 'üìö –∏–∑ —Å–ª–æ–≤–∞—Ä—è' : 'ü§ñ AI';
                } else {
                    translatedEl.textContent = '–ü–µ—Ä–µ–≤–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω';
                }
            } catch (error) {
                console.error('Translation error:', error);
                translatedEl.textContent = '–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞';
            }
        }

        function closeWordPopup() {
            const popup = document.getElementById('wordTranslationPopup');
            if (popup) {
                popup.classList.remove('visible');
            }
        }

        // Audio Player functions
        let playerUpdateInterval = null;

        function formatTime(seconds) {
            if (isNaN(seconds) || !isFinite(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updatePlayerUI() {
            if (!digestAudio) return;

            const progressFill = document.getElementById('playerProgressFill');
            const currentTimeEl = document.getElementById('playerCurrentTime');
            const durationEl = document.getElementById('playerDuration');

            if (progressFill && digestAudio.duration) {
                const progress = (digestAudio.currentTime / digestAudio.duration) * 100;
                progressFill.style.width = `${progress}%`;
            }

            if (currentTimeEl) {
                currentTimeEl.textContent = formatTime(digestAudio.currentTime);
            }

            if (durationEl && digestAudio.duration) {
                durationEl.textContent = formatTime(digestAudio.duration);
            }
        }

        function toggleDigestPlayer() {
            const btn = document.getElementById('playerBtn');
            if (!btn) return;

            if (!currentDigest || !currentDigest.audioUrl) {
                // No audio URL - show message
                btn.textContent = '!';
                setTimeout(() => { btn.textContent = '‚ñ∂'; }, 1000);
                return;
            }

            if (digestAudio && !digestAudio.paused) {
                // Pause
                digestAudio.pause();
                btn.textContent = '‚ñ∂';
                btn.classList.remove('playing');
                if (playerUpdateInterval) {
                    clearInterval(playerUpdateInterval);
                    playerUpdateInterval = null;
                }
            } else if (digestAudio) {
                // Resume
                digestAudio.play();
                btn.textContent = '‚è∏';
                btn.classList.add('playing');
                playerUpdateInterval = setInterval(updatePlayerUI, 100);
            } else {
                // Start new
                startDigestAudio();
            }

            if (tg?.HapticFeedback) {
                tg.HapticFeedback.impactOccurred('light');
            }
        }

        function startDigestAudio() {
            const btn = document.getElementById('playerBtn');
            if (!btn || !currentDigest?.audioUrl) return;

            btn.classList.add('loading');
            btn.textContent = '...';

            digestAudio = new Audio(currentDigest.audioUrl);
            digestAudio.volume = 1.0;

            digestAudio.onloadedmetadata = () => {
                updatePlayerUI();
            };

            digestAudio.oncanplay = () => {
                btn.classList.remove('loading');
                btn.classList.add('playing');
                btn.textContent = '‚è∏';
                digestAudio.play();
                playerUpdateInterval = setInterval(updatePlayerUI, 100);
            };

            digestAudio.onended = () => {
                resetPlayer();
            };

            digestAudio.onerror = () => {
                btn.classList.remove('loading');
                btn.textContent = '!';
                setTimeout(() => { btn.textContent = '‚ñ∂'; }, 2000);
                digestAudio = null;
            };
        }

        function seekDigestAudio(e) {
            if (!digestAudio || !digestAudio.duration) return;

            const progressBar = document.getElementById('playerProgressBar');
            if (!progressBar) return;

            const rect = progressBar.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const percent = clickX / rect.width;
            digestAudio.currentTime = percent * digestAudio.duration;
            updatePlayerUI();
        }

        function resetPlayer() {
            const btn = document.getElementById('playerBtn');
            const progressFill = document.getElementById('playerProgressFill');
            const currentTimeEl = document.getElementById('playerCurrentTime');

            if (playerUpdateInterval) {
                clearInterval(playerUpdateInterval);
                playerUpdateInterval = null;
            }

            if (digestAudio) {
                digestAudio.pause();
                digestAudio = null;
            }

            if (btn) {
                btn.classList.remove('playing', 'loading');
                btn.textContent = '‚ñ∂';
            }

            if (progressFill) {
                progressFill.style.width = '0%';
            }

            if (currentTimeEl) {
                currentTimeEl.textContent = '0:00';
            }
        }

        function stopDigestAudio() {
            resetPlayer();
        }

        // Dictionary functions
        async function loadDictionary() {
            const content = document.getElementById('dictionaryContent');
            const refreshBtn = document.getElementById('dictRefreshBtn');
            const wordCount = document.getElementById('dictWordCount');

            refreshBtn.classList.add('spinning');
            content.innerHTML = '<div class="loading">Loading dictionary...</div>';
            revealedTranslations.clear(); // Reset revealed state on reload
            markedAsRepeat.clear(); // Reset marked words on reload
            // Reset autoplay indices when loading new dictionary
            dictAutoplayIndexEnglish = 0;
            dictAutoplayIndexBoth = 0;

            try {
                const response = await fetch(DICTIONARY_API_URL);
                if (!response.ok) throw new Error('Failed to fetch');

                const data = await response.json();
                dictionaryWords = data.words || [];

                wordCount.textContent = dictionaryWords.length;

                if (dictionaryWords.length === 0) {
                    content.innerHTML = '<div class="loading">No words in dictionary</div>';
                    return;
                }

                // Pre-populate markedAsRepeat from stage field
                dictionaryWords.forEach(word => {
                    if (word.stage === 'repeat' && word._id) {
                        markedAsRepeat.add(word._id);
                    }
                });

                renderDictionary();

            } catch (error) {
                console.error('Error:', error);
                content.innerHTML = '<div class="error">Failed to load dictionary.<br>Please try again.</div>';
            } finally {
                refreshBtn.classList.remove('spinning');
            }
        }

        function renderDictionary() {
            const content = document.getElementById('dictionaryContent');

            // Update autoplay buttons state
            const englishBtn = document.getElementById('dictAutoplayEnglishBtn');
            const bothBtn = document.getElementById('dictAutoplayBothBtn');
            englishBtn.classList.toggle('active', dictAutoplayMode === 'english');
            bothBtn.classList.toggle('active', dictAutoplayMode === 'both');

            let html = '<div class="word-list">';

            dictionaryWords.forEach((word, index) => {
                html += renderDictWordCard(word, index);
            });

            html += '</div>';
            content.innerHTML = html;
        }

        function renderDictWordCard(word, index) {
            const audioUrl = word.audio || '';
            const isHighlighted = dictAutoplayMode && dictAutoplayIndex === index;
            const wordId = word._id || '';
            const isRevealed = revealedTranslations.has(index);
            const isRepeat = markedAsRepeat.has(wordId);

            // Build transcript line with meta info
            const transcriptParts = [];
            if (word.transcript && word.transcript !== 'None') {
                transcriptParts.push(`/${word.transcript}/`);
            }
            if (word.partOfSpeech) {
                transcriptParts.push(word.partOfSpeech);
            }
            if (word.level) {
                transcriptParts.push(word.level);
            }
            if (word.trainDate) {
                transcriptParts.push(word.trainDate);
            }
            const transcriptLine = transcriptParts.join(' ¬∑ ');

            return `
                <div class="word-card ${isHighlighted ? 'highlighted' : ''} ${isRepeat ? 'repeat-marked' : ''}" data-index="${index}">
                    <div class="word-header">
                        <div class="word-left">
                            <span class="word-number">${index + 1}.</span>
                            <span class="word-text">${escapeHtml(word.word)}</span>
                            <button class="repeat-btn ${isRepeat ? 'sent' : ''}" id="dict-repeat-btn-${index}"
                                    data-action="mark-repeat" data-word-id="${escapeHtml(wordId)}" data-widx="${index}"
                                    title="Mark for repeat">
                                ${isRepeat ? '‚úì' : 'üîÑ'}
                            </button>
                        </div>
                        <button class="audio-btn" id="dict-audio-btn-${index}"
                                data-action="play-dict" data-url="${escapeHtml(audioUrl)}" data-widx="${index}">
                            &#x1F50A;
                        </button>
                    </div>
                    ${transcriptLine ? `<div class="transcript">${escapeHtml(transcriptLine)}</div>` : ''}
                    <div class="translate ${isRevealed ? '' : 'hidden'}" data-action="reveal-translate" data-widx="${index}">${escapeHtml(word.translate)}</div>
                </div>
            `;
        }

        function playDictAudioSingle(url, wordIndex) {
            if (!url) return;

            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
                if (currentPlayingBtn) {
                    currentPlayingBtn.classList.remove('playing');
                }
            }

            if (tg?.HapticFeedback) {
                tg.HapticFeedback.impactOccurred('light');
            }

            const btn = document.getElementById(`dict-audio-btn-${wordIndex}`);
            currentPlayingBtn = btn;
            if (btn) btn.classList.add('playing');

            currentAudio = new Audio(url);
            currentAudio.volume = 1.0;

            currentAudio.onended = () => {
                if (btn) btn.classList.remove('playing');
                currentPlayingBtn = null;
            };

            currentAudio.onerror = () => {
                if (btn) btn.classList.remove('playing');
                currentPlayingBtn = null;
            };

            currentAudio.play().catch(() => {
                if (btn) btn.classList.remove('playing');
                currentPlayingBtn = null;
            });
        }

        async function toggleDictAutoplay(mode) {
            if (dictAutoplayMode === mode) {
                // Pause: save current index for this mode
                if (mode === 'english') {
                    dictAutoplayIndexEnglish = dictAutoplayIndex;
                } else if (mode === 'both') {
                    dictAutoplayIndexBoth = dictAutoplayIndex;
                }
                stopDictAutoplay();
                renderDictionary(); // Update UI to show paused state
            } else {
                await unlockAudio();
                stopDictAutoplay();
                dictAutoplayMode = mode;

                // Restore index for this mode
                if (mode === 'english') {
                    dictAutoplayIndex = dictAutoplayIndexEnglish;
                } else if (mode === 'both') {
                    dictAutoplayIndex = dictAutoplayIndexBoth;
                }

                // Ensure index is valid
                if (dictAutoplayIndex >= dictionaryWords.length) {
                    dictAutoplayIndex = 0;
                }

                renderDictionary();
                playNextDictWord();
            }
        }

        function stopDictAutoplay() {
            dictAutoplayMode = null;
            if (autoplayTimeout) {
                clearTimeout(autoplayTimeout);
                autoplayTimeout = null;
            }
            sharedAudio.pause();
            sharedAudio.onended = null;
            sharedAudio.onerror = null;

            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            if (window.speechSynthesis && window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }

            // Clear media session and release wake lock
            clearMediaSession();
            releaseWakeLock();
            document.querySelectorAll('#dictionaryContent .word-card.highlighted').forEach(el => {
                el.classList.remove('highlighted');
            });
            // Update buttons
            const englishBtn = document.getElementById('dictAutoplayEnglishBtn');
            const bothBtn = document.getElementById('dictAutoplayBothBtn');
            if (englishBtn) englishBtn.classList.remove('active');
            if (bothBtn) bothBtn.classList.remove('active');
        }

        function highlightDictWord(index) {
            document.querySelectorAll('#dictionaryContent .word-card.highlighted').forEach(el => {
                el.classList.remove('highlighted');
            });
            const cards = document.querySelectorAll('#dictionaryContent .word-card');
            if (cards[index]) {
                cards[index].classList.add('highlighted');
                cards[index].scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function playNextDictWord() {
            if (!dictAutoplayMode || dictionaryWords.length === 0) {
                stopDictAutoplay();
                return;
            }

            if (dictAutoplayIndex >= dictionaryWords.length) {
                // Reached end of list, stop and save position
                if (dictAutoplayMode === 'english') {
                    dictAutoplayIndexEnglish = dictAutoplayIndex;
                } else if (dictAutoplayMode === 'both') {
                    dictAutoplayIndexBoth = dictAutoplayIndex;
                }
                stopDictAutoplay();
                return;
            }

            const word = dictionaryWords[dictAutoplayIndex];
            highlightDictWord(dictAutoplayIndex);

            // Setup media session and wake lock on first word
            if (dictAutoplayIndex === 0 || dictAutoplayIndex === dictAutoplayIndexEnglish || dictAutoplayIndex === dictAutoplayIndexBoth) {
                setupVocabularyMediaSession(word.word, dictAutoplayMode);
                requestWakeLock();
            }

            if (dictAutoplayMode === 'english') {
                playDictWordAudio(word.audio, () => {
                    autoplayTimeout = setTimeout(() => {
                        dictAutoplayIndex++;
                        dictAutoplayIndexEnglish = dictAutoplayIndex;
                        playNextDictWord();
                    }, 1000);
                });
            } else if (dictAutoplayMode === 'both') {
                playDictWordAudio(word.audio, () => {
                    autoplayTimeout = setTimeout(() => {
                        speakRussian(word.word, () => {
                            autoplayTimeout = setTimeout(() => {
                                dictAutoplayIndex++;
                                dictAutoplayIndexBoth = dictAutoplayIndex;
                                playNextDictWord();
                            }, 2000);
                        });
                    }, 1000);
                });
            }
        }

        function playDictWordAudio(url, onComplete) {
            if (!url || !dictAutoplayMode) {
                if (onComplete) onComplete();
                return;
            }

            sharedAudio.pause();
            sharedAudio.onended = null;
            sharedAudio.onerror = null;

            sharedAudio.src = url;
            sharedAudio.currentTime = 0;
            sharedAudio.volume = 1.0;

            sharedAudio.onended = () => {
                if (onComplete) onComplete();
            };

            sharedAudio.onerror = () => {
                if (onComplete) onComplete();
            };

            sharedAudio.play().catch(() => {
                if (onComplete) onComplete();
            });
        }

        // Reveal translation on click
        function revealTranslation(wordIndex, element) {
            revealedTranslations.add(wordIndex);
            if (element) {
                element.classList.remove('hidden');
            }
            if (tg?.HapticFeedback) {
                tg.HapticFeedback.impactOccurred('light');
            }
        }

        // Mark word for repeat
        async function markWordForRepeat(wordId, wordIndex) {
            if (!wordId) {
                console.error('No word ID provided');
                return;
            }

            const btn = document.getElementById(`dict-repeat-btn-${wordIndex}`);
            if (!btn || btn.classList.contains('sent') || btn.classList.contains('sending')) {
                return;
            }

            btn.classList.add('sending');
            btn.textContent = '...';

            if (tg?.HapticFeedback) {
                tg.HapticFeedback.impactOccurred('medium');
            }

            try {
                const response = await fetch(MARK_REPEAT_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ wordId: wordId })
                });

                if (!response.ok) throw new Error('Failed to mark word');

                btn.classList.remove('sending');
                btn.classList.add('sent');
                btn.textContent = '‚úì';

                // Track this word as marked for repeat
                markedAsRepeat.add(wordId);

                if (tg?.HapticFeedback) {
                    tg.HapticFeedback.notificationOccurred('success');
                }

            } catch (error) {
                console.error('Error marking word for repeat:', error);
                btn.classList.remove('sending');
                btn.textContent = 'üîÑ';

                if (tg?.HapticFeedback) {
                    tg.HapticFeedback.notificationOccurred('error');
                }
            }
        }

        // Load New Batch function
        async function loadNewBatch() {
            if (dictionaryWords.length === 0) {
                alert('No words loaded. Please refresh dictionary first.');
                return;
            }

            // Get word IDs that are NOT marked as repeat
            const wordIdsToMark = dictionaryWords
                .filter(word => word._id && !markedAsRepeat.has(word._id))
                .map(word => word._id);

            if (wordIdsToMark.length === 0) {
                alert('All words have been marked for repeat. Loading new batch...');
                loadDictionary();
                return;
            }

            // Confirmation dialog
            const markedCount = markedAsRepeat.size;
            const unmarkedCount = wordIdsToMark.length;
            const confirmMsg = `Mark ${unmarkedCount} words as "new" and load next batch?\n\n` +
                `Words marked for repeat: ${markedCount}\n` +
                `Words to mark as new: ${unmarkedCount}`;

            if (!confirm(confirmMsg)) {
                return;
            }

            const btn = document.getElementById('loadNewBatchBtn');
            btn.disabled = true;
            btn.textContent = 'Loading...';

            if (tg?.HapticFeedback) {
                tg.HapticFeedback.impactOccurred('medium');
            }

            try {
                const response = await fetch(MARK_NEW_BATCH_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ wordIds: wordIdsToMark })
                });

                if (!response.ok) throw new Error('Failed to mark words');

                const result = await response.json();
                console.log('Marked as new:', result);

                // Clear tracking sets and reload dictionary
                markedAsRepeat.clear();
                revealedTranslations.clear();

                if (tg?.HapticFeedback) {
                    tg.HapticFeedback.notificationOccurred('success');
                }

                // Reload dictionary to get next batch
                loadDictionary();

            } catch (error) {
                console.error('Error loading new batch:', error);
                alert('Failed to load new batch. Please try again.');

                if (tg?.HapticFeedback) {
                    tg.HapticFeedback.notificationOccurred('error');
                }
            } finally {
                btn.disabled = false;
                btn.textContent = 'Load New Batch';
            }
        }

        // Quiz functions
        async function loadQuiz() {
            const content = document.getElementById('quizContent');
            const wordCount = document.getElementById('quizWordCount');

            // Show start screen
            wordCount.textContent = '10 words';
            content.innerHTML = `
                <div class="quiz-complete">
                    <div class="quiz-complete-icon">üéØ</div>
                    <div class="quiz-complete-title">Ready to Practice?</div>
                    <div class="quiz-complete-subtitle">Test your vocabulary with 10 random words</div>
                    <button class="quiz-next-btn" data-action="quiz-start" style="margin-top: 24px;">
                        Start Quiz
                    </button>
                </div>
            `;
        }

        async function startQuiz() {
            const content = document.getElementById('quizContent');
            const refreshBtn = document.getElementById('quizRefreshBtn');

            refreshBtn.classList.add('spinning');
            content.innerHTML = '<div class="loading">Loading quiz words...</div>';

            try {
                const response = await fetch(QUIZ_API_URL);
                if (!response.ok) throw new Error('Failed to fetch');

                const data = await response.json();
                // Get fresh 10 words each time
                quizWords = data.targets || [];
                quizDistractors = data.distractors || [];

                quizCurrentIndex = 0;
                quizAnswered = false;
                quizCorrectCount = 0;
                quizWrongCount = 0;
                prepareQuizQuestion();
                renderQuiz();

            } catch (error) {
                console.error('Error loading quiz:', error);
                content.innerHTML = '<div class="empty-state">Failed to load quiz. Tap refresh to try again.</div>';
            } finally {
                refreshBtn.classList.remove('spinning');
            }
        }

        function switchQuizTab(tab) {
            if (quizCurrentTab === tab) return;

            quizCurrentTab = tab;
            restartQuiz();

            // Update tab buttons
            document.querySelectorAll('#quizPage .tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.getAttribute('data-tab') === tab);
            });

            if (tg?.HapticFeedback) {
                tg.HapticFeedback.selectionChanged();
            }
        }

        async function restartQuiz() {
            // Load fresh quiz words from API
            await startQuiz();
        }

        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function prepareQuizQuestion() {
            if (quizWords.length === 0 || quizCurrentIndex >= quizWords.length) {
                quizOptions = [];
                return;
            }

            const currentWord = quizWords[quizCurrentIndex];

            // Get 3 random distractors from the distractors pool (different from current word)
            const distractors = quizDistractors
                .filter(w => w.word.toLowerCase() !== currentWord.word.toLowerCase())
                .sort(() => 0.5 - Math.random())
                .slice(0, 3);

            // Create options based on quiz type
            if (quizCurrentTab === 'activeRecall') {
                // Show translate, choose word
                quizOptions = [
                    { text: currentWord.word, isCorrect: true },
                    ...distractors.map(d => ({ text: d.word, isCorrect: false }))
                ];
            } else {
                // Show word, choose translate
                quizOptions = [
                    { text: currentWord.translate, isCorrect: true },
                    ...distractors.map(d => ({ text: d.translate, isCorrect: false }))
                ];
            }

            // Shuffle options
            quizOptions = shuffleArray(quizOptions);
        }

        function renderQuiz() {
            const content = document.getElementById('quizContent');

            if (quizWords.length === 0) {
                content.innerHTML = '<div class="empty-state">No words available for quiz.</div>';
                return;
            }

            // Check if quiz is complete
            if (quizCurrentIndex >= quizWords.length) {
                renderQuizComplete();
                return;
            }

            const currentWord = quizWords[quizCurrentIndex];
            const progress = ((quizCurrentIndex) / quizWords.length) * 100;

            let html = '<div class="quiz-container">';

            // Progress bar
            html += `
                <div class="quiz-card">
                    <div class="quiz-progress">
                        <span>${quizCurrentIndex + 1}</span>
                        <div class="quiz-progress-bar">
                            <div class="quiz-progress-fill" style="width: ${progress}%"></div>
                        </div>
                        <span>${quizWords.length}</span>
                    </div>

                    <div class="quiz-question">
                        <div class="quiz-question-label">
                            ${quizCurrentTab === 'activeRecall' ? 'What is the English word for:' : 'What is the translation of:'}
                        </div>
                        <div class="quiz-question-text">
                            ${quizCurrentTab === 'activeRecall' ? escapeHtml(currentWord.translate) : escapeHtml(currentWord.word)}
                        </div>
                        ${currentWord.audio ? `<button class="quiz-audio-btn" data-action="quiz-audio">üîä</button>` : ''}
                    </div>

                    <div class="quiz-options">
                        ${quizOptions.map((opt, idx) => `
                            <button class="quiz-option ${quizAnswered ? (opt.isCorrect ? 'correct' : (opt.selected ? 'wrong' : '')) : ''} ${quizAnswered ? 'disabled' : ''}"
                                    data-action="quiz-answer" data-option="${idx}">
                                ${escapeHtml(opt.text)}
                            </button>
                        `).join('')}
                    </div>
            `;

            if (quizAnswered) {
                const isCorrect = quizOptions.find(o => o.selected)?.isCorrect;
                html += `
                    <div class="quiz-result ${isCorrect ? 'correct' : 'wrong'}">
                        ${isCorrect ? '‚úì Correct!' : `‚úó Wrong! The answer is: ${quizCurrentTab === 'activeRecall' ? currentWord.word : currentWord.translate}`}
                    </div>
                `;
            }

            // Always show next/skip button
            html += `
                <button class="quiz-next-btn" data-action="quiz-next">
                    ${quizAnswered
                        ? (quizCurrentIndex + 1 >= quizWords.length ? 'See Results' : 'Next Question')
                        : (quizCurrentIndex + 1 >= quizWords.length ? 'Skip & See Results' : 'Skip')}
                </button>
            `;

            html += '</div>'; // quiz-card

            // Stats
            html += `
                <div class="quiz-stats">
                    <div class="quiz-stat">
                        <div class="quiz-stat-value correct">${quizCorrectCount}</div>
                        <div class="quiz-stat-label">Correct</div>
                    </div>
                    <div class="quiz-stat">
                        <div class="quiz-stat-value wrong">${quizWrongCount}</div>
                        <div class="quiz-stat-label">Wrong</div>
                    </div>
                </div>
            `;

            html += '</div>'; // quiz-container
            content.innerHTML = html;
        }

        function renderQuizComplete() {
            const content = document.getElementById('quizContent');
            const total = quizCorrectCount + quizWrongCount;
            const percentage = total > 0 ? Math.round((quizCorrectCount / total) * 100) : 0;

            let emoji = 'üéâ';
            let message = 'Excellent!';
            if (percentage < 50) {
                emoji = 'üìö';
                message = 'Keep practicing!';
            } else if (percentage < 80) {
                emoji = 'üëç';
                message = 'Good job!';
            }

            const html = `
                <div class="quiz-complete">
                    <div class="quiz-complete-icon">${emoji}</div>
                    <div class="quiz-complete-title">${message}</div>
                    <div class="quiz-complete-subtitle">You got ${quizCorrectCount} out of ${total} correct (${percentage}%)</div>

                    <div class="quiz-stats">
                        <div class="quiz-stat">
                            <div class="quiz-stat-value correct">${quizCorrectCount}</div>
                            <div class="quiz-stat-label">Correct</div>
                        </div>
                        <div class="quiz-stat">
                            <div class="quiz-stat-value wrong">${quizWrongCount}</div>
                            <div class="quiz-stat-label">Wrong</div>
                        </div>
                    </div>

                    <button class="quiz-next-btn" data-action="quiz-restart" style="margin-top: 24px;">
                        Restart Quiz
                    </button>
                </div>
            `;
            content.innerHTML = html;
        }

        async function handleQuizAnswer(optionIndex) {
            if (quizAnswered || optionIndex < 0 || optionIndex >= quizOptions.length) return;

            quizAnswered = true;
            quizOptions[optionIndex].selected = true;

            const isCorrect = quizOptions[optionIndex].isCorrect;
            if (isCorrect) {
                quizCorrectCount++;

                // Update word stage to "new" on server
                const currentWord = quizWords[quizCurrentIndex];
                if (currentWord && currentWord._id) {
                    const url = UPDATE_WORD_STAGE_API_URL + '?wordId=' + encodeURIComponent(currentWord._id) + '&stage=new';
                    console.log('[QUIZ] Updating word stage:', currentWord.word, 'ID:', currentWord._id);

                    try {
                        const xhr = new XMLHttpRequest();
                        xhr.timeout = 5000;
                        xhr.open('GET', url);
                        xhr.onload = function() {
                            if (xhr.status >= 200 && xhr.status < 300) {
                                console.log('[QUIZ] Word stage updated successfully:', currentWord.word);
                            } else {
                                console.error('[QUIZ] Failed to update word stage:', xhr.status, xhr.responseText);
                            }
                        };
                        xhr.onerror = function() {
                            console.error('[QUIZ] Network error updating word stage');
                        };
                        xhr.send();
                    } catch (error) {
                        console.error('[QUIZ] Error updating word stage:', error);
                    }
                }

                if (tg?.HapticFeedback) {
                    tg.HapticFeedback.notificationOccurred('success');
                }
            } else {
                quizWrongCount++;
                if (tg?.HapticFeedback) {
                    tg.HapticFeedback.notificationOccurred('error');
                }
            }

            renderQuiz();
        }

        function nextQuizQuestion() {
            quizCurrentIndex++;
            quizAnswered = false;
            prepareQuizQuestion();
            renderQuiz();
        }

        function playQuizAudio() {
            if (quizCurrentIndex >= quizWords.length) return;

            const currentWord = quizWords[quizCurrentIndex];
            if (!currentWord.audio) return;

            const audio = new Audio(currentWord.audio);
            audio.play().catch(console.error);
        }

        // Podcasts functions
        async function checkPodcastTranscripts() {
            if (podcastEpisodes.length === 0) return;

            const audioUrls = podcastEpisodes.map(ep => ep.audioUrl).join(',');
            const url = CHECK_TRANSCRIPTS_API_URL + '?urls=' + encodeURIComponent(audioUrls);

            try {
                const response = await fetch(url);
                const data = await response.json();
                podcastTranscripts = data;
                console.log('Transcript availability:', data);
            } catch (error) {
                console.error('Error checking transcripts:', error);
                podcastTranscripts = {};
            }
        }

        async function loadPodcasts() {
            if (isLoading) return;
            isLoading = true;

            const content = document.getElementById('podcastsContent');
            const refreshBtn = document.getElementById('podcastsRefreshBtn');
            const podcastCount = document.getElementById('podcastCount');

            refreshBtn.classList.add('spinning');
            content.innerHTML = '<div class="loading">Loading podcasts...</div>';

            try {
                console.log('Loading podcasts from:', PODCASTS_API_URL);

                // Try XMLHttpRequest for better mobile compatibility
                const data = await new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();
                    xhr.timeout = 10000; // 10 second timeout
                    xhr.ontimeout = () => reject(new Error('Request timeout'));
                    xhr.onerror = () => reject(new Error('Network error'));
                    xhr.onload = function() {
                        if (xhr.status >= 200 && xhr.status < 300) {
                            try {
                                resolve(JSON.parse(xhr.responseText));
                            } catch (e) {
                                reject(new Error('Invalid JSON: ' + e.message));
                            }
                        } else {
                            reject(new Error('HTTP ' + xhr.status));
                        }
                    };
                    xhr.open('GET', PODCASTS_API_URL);
                    xhr.send();
                });

                console.log('Podcasts loaded:', data);
                podcastEpisodes = data.episodes || [];

                podcastCount.textContent = podcastEpisodes.length;

                if (podcastEpisodes.length === 0) {
                    content.innerHTML = '<div class="loading">No podcasts available</div>';
                    return;
                }

                // Check which podcasts have transcripts
                await checkPodcastTranscripts();

                renderPodcasts();

            } catch (error) {
                console.error('Error loading podcasts:', error);
                content.innerHTML = '<div class="error">Failed to load podcasts: ' + error.message + '<br>Please try again.</div>';
            } finally {
                isLoading = false;
                refreshBtn.classList.remove('spinning');
            }
        }

        function renderPodcasts() {
            const content = document.getElementById('podcastsContent');

            let html = '';
            podcastEpisodes.forEach((episode, index) => {
                const isPlaying = currentPlayingPodcast === index;
                const btnText = isPlaying ? '‚è∏' : '‚ñ∂';
                const btnClass = isPlaying ? 'playing' : '';

                // Format duration from seconds to MM:SS
                const durationSeconds = parseInt(episode.duration) || 0;
                const minutes = Math.floor(durationSeconds / 60);
                const seconds = durationSeconds % 60;
                const formattedDuration = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                // Get current time for this podcast if playing
                let currentTime = 0;
                let currentTimeFormatted = '0:00';
                let progressPercent = 0;

                if (isPlaying && currentPodcastAudio) {
                    currentTime = currentPodcastAudio.currentTime || 0;
                    const curMin = Math.floor(currentTime / 60);
                    const curSec = Math.floor(currentTime % 60);
                    currentTimeFormatted = `${curMin}:${curSec.toString().padStart(2, '0')}`;
                    progressPercent = durationSeconds > 0 ? (currentTime / durationSeconds) * 100 : 0;
                }

                const isDescriptionExpanded = expandedPodcastDescriptions.has(index);
                const descriptionClass = isDescriptionExpanded ? 'expanded' : '';
                const showDescBtnText = isDescriptionExpanded ? '‚ñ≤ Hide description' : '‚ñº Show description';

                html += `
                    <div class="podcast-card">
                        <div class="podcast-header">
                            <div class="podcast-date">${episode.date}</div>
                            <div class="podcast-duration">${formattedDuration}</div>
                        </div>
                        <div class="podcast-title">${episode.title}</div>
                        <button class="podcast-show-description-btn"
                                data-action="toggle-podcast-description"
                                data-index="${index}">
                            ${showDescBtnText}
                        </button>
                        <div class="podcast-description ${descriptionClass}">
                            ${episode.description || ''}
                        </div>

                        ${(() => {
                            const isTranscribing = transcribingPodcasts.has(index);
                            const hasTranscriptInCache = podcastTranscripts[episode.audioUrl];
                            const hasTranscript = podcastTranscripts[index];
                            const segments = podcastTranscriptSegments[index];

                            if (isTranscribing) {
                                return `<div style="padding: 12px; text-align: center; color: var(--tg-theme-hint-color);">
                                    ‚è≥ Transcribing... This may take 3-5 minutes
                                </div>`;
                            } else if (hasTranscript) {
                                // If we have segments with timestamps, render them separately for highlighting
                                if (segments && segments.length > 0 && isPlaying) {
                                    const currentTime = currentPodcastAudio ? currentPodcastAudio.currentTime : 0;
                                    const autoScrollActive = autoScrollEnabled[index] !== false;
                                    return `<div style="margin-top: 12px; position: relative;">
                                        <div id="transcript-${index}"
                                             style="padding: 12px; background: rgba(0,0,0,0.05); border-radius: 8px; max-height: 300px; overflow-y: auto; font-size: 14px; line-height: 1.6;"
                                             onscroll="handleTranscriptScroll(${index})">
                                            ${segments.map((seg, segIndex) => {
                                                const isActive = currentTime >= seg.start && currentTime < seg.end;
                                                const time = formatTime(seg.start);
                                                return `<div id="segment-${index}-${segIndex}"
                                                         class="transcript-segment ${isActive ? 'active' : ''}"
                                                         style="padding: 4px 0; transition: background 0.2s ease, padding 0.2s ease;">
                                                    <span style="color: var(--tg-theme-hint-color); font-size: 12px; margin-right: 8px;">[${time}]</span>
                                                    <span>${seg.text.trim()}</span>
                                                </div>`;
                                            }).join('')}
                                        </div>
                                    </div>`;
                                } else {
                                    // Fallback to plain text display
                                    return `<div style="margin-top: 12px;">
                                        <div style="padding: 12px; background: rgba(0,0,0,0.05); border-radius: 8px; max-height: 300px; overflow-y: auto; white-space: pre-wrap; font-size: 14px; line-height: 1.6;">
                                            ${hasTranscript}
                                        </div>
                                    </div>`;
                                }
                            } else {
                                const btnStyle = hasTranscriptInCache
                                    ? 'margin-top: 8px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: 2px solid #667eea;'
                                    : 'margin-top: 8px;';
                                const btnIcon = hasTranscriptInCache ? '‚úÖ' : 'üìù';
                                const btnText = hasTranscriptInCache ? 'Show Transcript (Cached)' : 'Show Full Transcript';
                                return `<button class="podcast-show-description-btn"
                                        data-action="transcribe-podcast"
                                        data-index="${index}"
                                        data-url="${episode.audioUrl}"
                                        style="${btnStyle}">
                                    ${btnIcon} ${btnText}
                                </button>`;
                            }
                        })()}

                        ${isPlaying ? `
                        <div class="podcast-player">
                            <div class="podcast-progress-container"
                                 data-action="seek-podcast"
                                 data-index="${index}">
                                <div class="podcast-progress-bar" style="width: ${progressPercent}%"></div>
                            </div>
                            <div class="podcast-time">
                                <span>${currentTimeFormatted}</span>
                                <span>${formattedDuration}</span>
                            </div>
                            <div class="podcast-controls">
                                <button class="podcast-control-btn"
                                        data-action="rewind-podcast"
                                        data-index="${index}">
                                    ‚è™
                                </button>
                                <button class="podcast-control-btn"
                                        data-action="play-podcast"
                                        data-index="${index}"
                                        data-url="${episode.audioUrl}">
                                    ${btnText}
                                </button>
                                <button class="podcast-control-btn"
                                        data-action="forward-podcast"
                                        data-index="${index}">
                                    ‚è©
                                </button>
                            </div>
                        </div>
                        ` : `
                        <button class="podcast-play-btn ${btnClass}"
                                data-action="play-podcast"
                                data-index="${index}"
                                data-url="${episode.audioUrl}">
                            ${btnText} Play
                        </button>
                        `}
                    </div>
                `;
            });

            content.innerHTML = html;
        }

        function playPodcast(index, audioUrl) {
            if (currentPlayingPodcast === index && currentPodcastAudio && !currentPodcastAudio.paused) {
                // Pause current
                currentPodcastAudio.pause();
                stopPodcastProgressUpdate();
                currentPlayingPodcast = null;
                renderPodcasts();
            } else {
                // Stop any playing podcast
                if (currentPodcastAudio) {
                    currentPodcastAudio.pause();
                    currentPodcastAudio.currentTime = 0;
                    stopPodcastProgressUpdate();
                }

                // Play new podcast
                currentPodcastAudio = new Audio();
                currentPodcastAudio.preload = 'metadata';

                currentPlayingPodcast = index;
                currentPodcastIndex = index;

                // Enable auto-scroll by default for this podcast
                autoScrollEnabled[index] = true;

                // DON'T render here - will render after play() succeeds

                // Use audio proxy to avoid redirect issues on mobile
                const proxiedUrl = AUDIO_PROXY_URL + '?url=' + encodeURIComponent(audioUrl);
                console.log('Using proxy:', proxiedUrl);

                // Set source and load
                currentPodcastAudio.src = proxiedUrl;
                currentPodcastAudio.load();

                // Add event listeners before playing
                currentPodcastAudio.onended = () => {
                    currentPlayingPodcast = null;
                    stopPodcastProgressUpdate();
                    clearMediaSession();
                    releaseWakeLock();
                    renderPodcasts();
                };

                currentPodcastAudio.onerror = (e) => {
                    console.error('Audio error:', audioUrl, e);
                    console.error('Error details:', {
                        error: currentPodcastAudio.error,
                        code: currentPodcastAudio.error?.code,
                        message: currentPodcastAudio.error?.message
                    });
                    currentPlayingPodcast = null;
                    stopPodcastProgressUpdate();
                    renderPodcasts();
                    alert('Failed to load podcast audio. Error code: ' + (currentPodcastAudio.error?.code || 'unknown'));
                };

                currentPodcastAudio.onloadedmetadata = () => {
                    console.log('Podcast metadata loaded:', audioUrl);
                };

                // Try to play
                currentPodcastAudio.play()
                    .then(() => {
                        console.log('Podcast playing:', audioUrl);
                        renderPodcasts(); // Re-render to show player controls
                        startPodcastProgressUpdate();
                        // Setup media controls and wake lock
                        setupMediaSession(podcastEpisodes[index]);
                        requestWakeLock();
                    })
                    .catch(error => {
                        console.error('Error playing podcast:', error);
                        console.error('Error name:', error.name);
                        console.error('Error message:', error.message);
                        currentPlayingPodcast = null;
                        stopPodcastProgressUpdate();
                        renderPodcasts();

                        let errorMsg = 'Failed to play podcast. ';
                        if (error.name === 'NotAllowedError') {
                            errorMsg += 'Browser blocked autoplay. Please try again.';
                        } else if (error.name === 'NotSupportedError') {
                            errorMsg += 'Audio format not supported.';
                        } else {
                            errorMsg += error.message || 'Please try again.';
                        }
                        alert(errorMsg);
                    });
            }
        }

        function stopPodcast() {
            if (currentPodcastAudio) {
                currentPodcastAudio.pause();
                currentPodcastAudio.currentTime = 0;
                currentPodcastAudio = null;
            }
            currentPlayingPodcast = null;
            // Clear media session and release wake lock
            clearMediaSession();
            releaseWakeLock();
        }

        // New dedicated player screen functions
        async function openPodcastPlayer(index, audioUrl) {
            // Stop any currently playing podcast
            if (currentPodcastAudio) {
                currentPodcastAudio.pause();
                stopPodcastProgressUpdate();
            }

            // Switch to player page
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            document.getElementById('podcastPlayerPage').classList.add('active');

            // Set up player
            const episode = podcastEpisodes[index];
            document.getElementById('playerPodcastTitle').textContent = episode.title;

            currentPodcastIndex = index;
            currentPlayingPodcast = index;
            autoScrollEnabled[index] = true;

            // Load transcript if we only have the flag (true) but not the actual data
            const transcriptValue = podcastTranscripts[index] || podcastTranscripts[episode.audioUrl];
            if (transcriptValue === true) {
                // We know transcript exists but haven't loaded it yet
                await loadFullTranscript(index, episode.audioUrl);
            }

            // Render transcript
            renderPlayerTranscript();

            // Set up audio
            currentPodcastAudio = new Audio();
            currentPodcastAudio.preload = 'metadata';

            const proxiedUrl = AUDIO_PROXY_URL + '?url=' + encodeURIComponent(audioUrl);
            currentPodcastAudio.src = proxiedUrl;
            currentPodcastAudio.load();

            currentPodcastAudio.onended = () => {
                document.getElementById('playerPlayPauseBtn').textContent = '‚ñ∂';
                stopPodcastProgressUpdate();
                clearMediaSession();
                releaseWakeLock();
            };

            currentPodcastAudio.onerror = (e) => {
                console.error('Audio error:', audioUrl, e);
                alert('Failed to load podcast audio. Error: ' + (currentPodcastAudio.error?.code || 'unknown'));
            };

            currentPodcastAudio.onloadedmetadata = () => {
                const duration = currentPodcastAudio.duration || 0;
                const minutes = Math.floor(duration / 60);
                const seconds = Math.floor(duration % 60);
                document.getElementById('playerTotalTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            };

            // Auto-play
            currentPodcastAudio.play()
                .then(() => {
                    document.getElementById('playerPlayPauseBtn').textContent = '‚è∏';
                    startPodcastProgressUpdate();
                    // Setup media controls and wake lock
                    setupMediaSession(episode);
                    requestWakeLock();
                })
                .catch(error => {
                    console.error('Error playing podcast:', error);
                    alert('Failed to play podcast. Browser may have blocked autoplay.');
                });
        }

        function closePodcastPlayer() {
            // Stop audio and progress updates
            if (currentPodcastAudio) {
                currentPodcastAudio.pause();
                currentPodcastAudio = null;
            }
            stopPodcastProgressUpdate();
            // Clear media session and release wake lock
            clearMediaSession();
            releaseWakeLock();
            currentPlayingPodcast = null;
            currentPodcastIndex = null;

            // Switch back to podcasts page manually (avoid navigateToPage which might have side effects)
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            document.getElementById('podcastsPage').classList.add('active');

            // Update currentPage variable
            currentPage = 'podcasts';
        }

        function togglePlayerPlayPause() {
            if (!currentPodcastAudio) return;

            if (currentPodcastAudio.paused) {
                currentPodcastAudio.play()
                    .then(() => {
                        document.getElementById('playerPlayPauseBtn').textContent = '‚è∏';
                        startPodcastProgressUpdate();
                        requestWakeLock(); // Re-acquire wake lock on resume
                    })
                    .catch(error => {
                        console.error('Error playing:', error);
                    });
            } else {
                currentPodcastAudio.pause();
                document.getElementById('playerPlayPauseBtn').textContent = '‚ñ∂';
                stopPodcastProgressUpdate();
                releaseWakeLock(); // Release wake lock on pause
            }
        }

        function seekPlayerPodcast(target, event) {
            if (!currentPodcastAudio) return;

            const rect = target.getBoundingClientRect();
            const clickX = (event.clientX || event.touches?.[0]?.clientX) - rect.left;
            const percent = clickX / rect.width;
            const newTime = percent * (currentPodcastAudio.duration || 0);

            currentPodcastAudio.currentTime = Math.max(0, Math.min(newTime, currentPodcastAudio.duration || 0));
        }

        async function loadFullTranscript(index, audioUrl) {
            console.log('[PLAYER] Loading full transcript for:', audioUrl);
            const url = TRANSCRIBE_API_URL + '?audioUrl=' + encodeURIComponent(audioUrl);

            try {
                const xhr = new XMLHttpRequest();
                xhr.timeout = 60000; // 60 seconds
                xhr.ontimeout = () => {
                    throw new Error('Transcript load timeout');
                };
                xhr.onerror = () => {
                    throw new Error('Network error');
                };

                const response = await new Promise((resolve, reject) => {
                    xhr.onload = function() {
                        if (xhr.status >= 200 && xhr.status < 300) {
                            try {
                                resolve(JSON.parse(xhr.responseText));
                            } catch (e) {
                                reject(new Error('Invalid response: ' + e.message));
                            }
                        } else {
                            reject(new Error('HTTP ' + xhr.status));
                        }
                    };
                    xhr.open('GET', url);
                    xhr.send();
                });

                let transcript = response.transcript || 'No transcript available';
                let segments = [];

                // Parse nested JSON if it's a string
                if (typeof transcript === 'string' && transcript.startsWith('{')) {
                    try {
                        const parsed = JSON.parse(transcript);
                        if (parsed.data && typeof parsed.data === 'string') {
                            const innerParsed = JSON.parse(parsed.data);
                            if (innerParsed.segments && Array.isArray(innerParsed.segments)) {
                                segments = innerParsed.segments;
                                // Format with timestamps
                                transcript = segments.map(seg => {
                                    const time = formatTime(seg.start);
                                    return `[${time}] ${seg.text.trim()}`;
                                }).join('\n\n');
                            } else if (innerParsed.text) {
                                transcript = innerParsed.text;
                            }
                        }
                    } catch (parseErr) {
                        console.warn('Could not parse nested JSON:', parseErr);
                    }
                }

                podcastTranscripts[index] = transcript;
                podcastTranscriptSegments[index] = segments;
                console.log('[PLAYER] Transcript loaded:', segments.length, 'segments');

            } catch (error) {
                console.error('[PLAYER] Error loading transcript:', error);
                // Don't throw - just keep the flag, user can still transcribe
            }
        }

        function renderPlayerTranscript() {
            const container = document.getElementById('playerTranscript');
            const index = currentPodcastIndex;

            if (index === null) {
                container.innerHTML = '<div style="text-align: center; color: var(--tg-theme-hint-color);">No podcast selected</div>';
                return;
            }

            const episode = podcastEpisodes[index];
            const segments = podcastTranscriptSegments[index];

            // Transcript can be stored by index OR by URL
            const transcript = podcastTranscripts[index] || podcastTranscripts[episode.audioUrl];

            console.log('[PLAYER] Rendering transcript for index:', index, 'has transcript:', !!transcript, 'segments:', segments?.length || 0);

            if (!transcript) {
                // Check if currently transcribing
                const isTranscribing = transcribingPodcasts.has(index);
                if (isTranscribing) {
                    container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--tg-theme-hint-color);">‚è≥ Transcribing... This may take 3-5 minutes</div>';
                } else {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <div style="margin-bottom: 16px; color: var(--tg-theme-hint-color);">No transcript available</div>
                            <button class="podcast-show-description-btn"
                                    data-action="transcribe-podcast"
                                    data-index="${index}"
                                    data-url="${episode.audioUrl}">
                                üìù Get Transcript
                            </button>
                        </div>
                    `;
                }
                return;
            }

            if (segments && segments.length > 0) {
                const html = segments.map((seg, segIndex) => {
                    const time = formatTime(seg.start);
                    return `<div id="player-segment-${segIndex}"
                             class="transcript-segment"
                             style="padding: 8px 0; transition: background 0.2s ease, padding 0.2s ease;">
                        <span style="color: var(--tg-theme-hint-color); font-size: 12px; margin-right: 8px; font-weight: 500;">[${time}]</span>
                        <span style="line-height: 1.6;">${seg.text.trim()}</span>
                    </div>`;
                }).join('');
                container.innerHTML = html;
            } else {
                container.innerHTML = `<div style="white-space: pre-wrap; line-height: 1.6;">${transcript}</div>`;
            }
        }

        function rewindPodcast(seconds = 15) {
            if (currentPodcastAudio) {
                currentPodcastAudio.currentTime = Math.max(0, currentPodcastAudio.currentTime - seconds);
                renderPodcasts();
            }
        }

        function forwardPodcast(seconds = 15) {
            if (currentPodcastAudio) {
                currentPodcastAudio.currentTime = Math.min(
                    currentPodcastAudio.duration || 0,
                    currentPodcastAudio.currentTime + seconds
                );
                renderPodcasts();
            }
        }

        function seekPodcast(index, target, event) {
            if (currentPlayingPodcast !== index || !currentPodcastAudio) return;

            const progressBar = target;
            const rect = progressBar.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const percent = Math.max(0, Math.min(1, clickX / rect.width));

            const duration = currentPodcastAudio.duration || 0;
            currentPodcastAudio.currentTime = duration * percent;
            renderPodcasts();
        }

        // Update progress bar while playing
        let podcastProgressInterval = null;

        function startPodcastProgressUpdate() {
            if (podcastProgressInterval) {
                clearInterval(podcastProgressInterval);
            }
            podcastProgressInterval = setInterval(() => {
                if (currentPodcastAudio && !currentPodcastAudio.paused) {
                    // Update only progress bar, NOT full re-render
                    updatePodcastProgress();
                    // Update active segment class (without re-rendering)
                    updateActiveTranscriptSegment();
                    // Auto-scroll to active segment
                    scrollToActiveTranscriptSegment();
                }
            }, 200);

            // Start timestamp synchronization check
            startTimestampSync();
        }

        let lastScrolledSegment = null; // Track last scrolled segment
        let lastTargetScroll = null; // Track last target scroll position
        let isProgrammaticScroll = false; // Flag to ignore programmatic scrolls
        let activeTranscriptIndex = 0; // Current active segment index
        let lastUserScrollTime = 0; // Last time user manually scrolled
        let syncCheckInterval = null; // Interval for timestamp sync check

        function updatePodcastProgress() {
            if (!currentPodcastAudio || currentPodcastIndex === null) return;

            // Check if we're on the player page
            const playerPage = document.getElementById('podcastPlayerPage');
            const isOnPlayerPage = playerPage && playerPage.classList.contains('active');

            if (isOnPlayerPage) {
                // Update player page UI
                const progressBar = document.getElementById('playerProgressBar');
                if (progressBar) {
                    const percent = (currentPodcastAudio.currentTime / currentPodcastAudio.duration) * 100;
                    progressBar.style.width = percent + '%';
                }

                const currentTimeSpan = document.getElementById('playerCurrentTime');
                if (currentTimeSpan) {
                    currentTimeSpan.textContent = formatTime(currentPodcastAudio.currentTime);
                }
            } else {
                // Update old podcasts list UI (if still needed)
                const progressContainer = document.querySelector(`[data-index="${currentPodcastIndex}"][data-action="seek-podcast"]`);
                if (progressContainer) {
                    const progressBar = progressContainer.querySelector('.podcast-progress-bar');
                    if (progressBar) {
                        const percent = (currentPodcastAudio.currentTime / currentPodcastAudio.duration) * 100;
                        progressBar.style.width = percent + '%';
                    }

                    const playerDiv = progressContainer.parentElement;
                    if (playerDiv) {
                        const timeDisplay = playerDiv.querySelector('.podcast-time');
                        if (timeDisplay) {
                            const spans = timeDisplay.querySelectorAll('span');
                            if (spans.length >= 2) {
                                spans[0].textContent = formatTime(currentPodcastAudio.currentTime);
                                spans[1].textContent = formatTime(currentPodcastAudio.duration);
                            }
                        }
                    }
                }
            }
        }

        function updateActiveTranscriptSegment() {
            if (!currentPodcastAudio || currentPodcastIndex === null) return;

            const segments = podcastTranscriptSegments[currentPodcastIndex];
            if (!segments || segments.length === 0) return;

            const currentTime = currentPodcastAudio.currentTime;
            const activeSegmentIndex = segments.findIndex(seg =>
                currentTime >= seg.start && currentTime < seg.end
            );

            // Update global active index (used by sync checker)
            if (activeSegmentIndex !== -1) {
                activeTranscriptIndex = activeSegmentIndex;
            }

            // Check if we're on player page
            const playerPage = document.getElementById('podcastPlayerPage');
            const isOnPlayerPage = playerPage && playerPage.classList.contains('active');

            let container;
            if (isOnPlayerPage) {
                container = document.getElementById('playerTranscript');
            } else {
                container = document.getElementById(`transcript-${currentPodcastIndex}`);
            }

            if (!container) return;

            // Remove active class from all segments
            const allSegments = container.querySelectorAll('.transcript-segment');
            allSegments.forEach(seg => seg.classList.remove('active'));

            // Add active class to current segment
            if (activeSegmentIndex !== -1) {
                let activeElement;
                if (isOnPlayerPage) {
                    activeElement = document.getElementById(`player-segment-${activeSegmentIndex}`);
                } else {
                    activeElement = document.getElementById(`segment-${currentPodcastIndex}-${activeSegmentIndex}`);
                }
                if (activeElement) {
                    activeElement.classList.add('active');
                }
            }
        }

        function scrollToActiveTranscriptSegment() {
            if (!currentPodcastAudio || currentPodcastIndex === null) return;
            if (autoScrollEnabled[currentPodcastIndex] === false) return;

            const segments = podcastTranscriptSegments[currentPodcastIndex];
            if (!segments || segments.length === 0) return;

            const currentTime = currentPodcastAudio.currentTime;
            const activeSegmentIndex = segments.findIndex(seg =>
                currentTime >= seg.start && currentTime < seg.end
            );

            if (activeSegmentIndex !== -1) {
                if (lastScrolledSegment === activeSegmentIndex) return;
                lastScrolledSegment = activeSegmentIndex;

                // Check if we're on player page
                const playerPage = document.getElementById('podcastPlayerPage');
                const isOnPlayerPage = playerPage && playerPage.classList.contains('active');

                let activeElement, container;
                if (isOnPlayerPage) {
                    activeElement = document.getElementById(`player-segment-${activeSegmentIndex}`);
                    container = document.getElementById('playerTranscript');
                } else {
                    activeElement = document.getElementById(`segment-${currentPodcastIndex}-${activeSegmentIndex}`);
                    container = document.getElementById(`transcript-${currentPodcastIndex}`);
                }

                if (activeElement && container) {
                    const elementTop = activeElement.offsetTop;
                    const elementHeight = activeElement.clientHeight;
                    const containerHeight = container.clientHeight;
                    const currentScroll = container.scrollTop;

                    // Calculate where element center should be (center of viewport)
                    const elementCenter = elementTop + (elementHeight / 2);
                    const targetScroll = elementCenter - (containerHeight / 2);

                    // Clamp to valid range
                    const newScroll = Math.max(0, targetScroll);

                    console.log('[SCROLL] elemTop:', elementTop, 'center:', elementCenter, 'targetScroll:', targetScroll, 'newScroll:', newScroll, 'current:', currentScroll, 'lastTarget:', lastTargetScroll);

                    // Only scroll if target changed (avoid re-scrolling same position)
                    if (lastTargetScroll !== null && Math.abs(newScroll - lastTargetScroll) < 2) {
                        console.log('[SCROLL] Already scrolling to this target');
                        return;
                    }

                    console.log('[SCROLL] Centering element. Scrolling to:', newScroll);

                    lastTargetScroll = newScroll;
                    isProgrammaticScroll = true;

                    // Direct scroll (no animation for testing)
                    container.scrollTop = newScroll;

                    console.log('[SCROLL] After scroll, container.scrollTop:', container.scrollTop);

                    setTimeout(() => {
                        isProgrammaticScroll = false;
                    }, 100);
                }
            }
        }

        function handleTranscriptScroll(index) {
            // Ignore programmatic scrolls
            if (isProgrammaticScroll) return;

            // Record user scroll time for sync logic
            lastUserScrollTime = Date.now();

            // User scrolled manually - disable auto-scroll temporarily
            autoScrollEnabled[index] = false;

            // Clear existing timeout
            if (userScrollTimeout) {
                clearTimeout(userScrollTimeout);
            }

            // Re-enable auto-scroll after 3 seconds of no scrolling
            userScrollTimeout = setTimeout(() => {
                autoScrollEnabled[index] = true;
            }, 3000);
        }

        // Timestamp-based synchronization to prevent drift on long podcasts
        function startTimestampSync() {
            if (syncCheckInterval) {
                clearInterval(syncCheckInterval);
            }

            // Check sync every 1 second
            syncCheckInterval = setInterval(() => {
                checkAndFixTranscriptSync();
            }, 1000);
        }

        function stopTimestampSync() {
            if (syncCheckInterval) {
                clearInterval(syncCheckInterval);
                syncCheckInterval = null;
            }
            activeTranscriptIndex = 0;
            lastUserScrollTime = 0;
        }

        function checkAndFixTranscriptSync() {
            if (!currentPodcastAudio || currentPodcastIndex === null) return;
            if (autoScrollEnabled[currentPodcastIndex] === false) return;

            const segments = podcastTranscriptSegments[currentPodcastIndex];
            if (!segments || segments.length === 0) return;

            // Don't sync if user scrolled recently (within 3 seconds)
            const timeSinceUserScroll = Date.now() - lastUserScrollTime;
            if (timeSinceUserScroll < 3000) {
                return;
            }

            const currentTime = currentPodcastAudio.currentTime;

            // Find which segment SHOULD be active based on timestamp
            const correctSegmentIndex = segments.findIndex(seg =>
                currentTime >= seg.start && currentTime < seg.end
            );

            // If no segment found (between segments), don't sync
            if (correctSegmentIndex === -1) return;

            // If activeTranscriptIndex differs from correct index, fix it
            if (activeTranscriptIndex !== correctSegmentIndex) {
                const drift = Math.abs(correctSegmentIndex - activeTranscriptIndex);

                // Only correct if drift is significant (more than 1 segment)
                if (drift > 1) {
                    console.log(`[SYNC] Detected drift: expected segment ${correctSegmentIndex}, but at ${activeTranscriptIndex}. Correcting...`);
                    activeTranscriptIndex = correctSegmentIndex;
                    lastScrolledSegment = null; // Force re-scroll
                    scrollToActiveTranscriptSegment();
                }
            }

            // Update active index
            activeTranscriptIndex = correctSegmentIndex;
        }

        function stopPodcastProgressUpdate() {
            if (podcastProgressInterval) {
                clearInterval(podcastProgressInterval);
                podcastProgressInterval = null;
            }
            // Stop timestamp synchronization
            stopTimestampSync();
        }

        // Media Session API - shows system media controls
        function setupMediaSession(episode) {
            if (!('mediaSession' in navigator)) {
                console.log('Media Session API not supported');
                return;
            }

            navigator.mediaSession.metadata = new MediaMetadata({
                title: episode.title,
                artist: 'VOA Learning English',
                album: 'Podcasts',
                artwork: [
                    { src: 'https://vocab.aimediaflow.net/icon-192.png', sizes: '192x192', type: 'image/png' },
                    { src: 'https://vocab.aimediaflow.net/icon-512.png', sizes: '512x512', type: 'image/png' }
                ]
            });

            // Set up action handlers
            navigator.mediaSession.setActionHandler('play', () => {
                if (currentPodcastAudio) {
                    currentPodcastAudio.play();
                }
            });

            navigator.mediaSession.setActionHandler('pause', () => {
                if (currentPodcastAudio) {
                    currentPodcastAudio.pause();
                }
            });

            navigator.mediaSession.setActionHandler('seekbackward', () => {
                if (currentPodcastAudio) {
                    currentPodcastAudio.currentTime = Math.max(0, currentPodcastAudio.currentTime - 10);
                }
            });

            navigator.mediaSession.setActionHandler('seekforward', () => {
                if (currentPodcastAudio) {
                    currentPodcastAudio.currentTime = Math.min(
                        currentPodcastAudio.duration || 0,
                        currentPodcastAudio.currentTime + 10
                    );
                }
            });

            console.log('Media Session configured for:', episode.title);
        }

        function clearMediaSession() {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = null;
                navigator.mediaSession.setActionHandler('play', null);
                navigator.mediaSession.setActionHandler('pause', null);
                navigator.mediaSession.setActionHandler('seekbackward', null);
                navigator.mediaSession.setActionHandler('seekforward', null);
            }
        }

        // Wake Lock API - prevents screen from sleeping
        async function requestWakeLock() {
            if (!('wakeLock' in navigator)) {
                console.log('Wake Lock API not supported');
                return;
            }

            try {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake Lock acquired');

                wakeLock.addEventListener('release', () => {
                    console.log('Wake Lock released');
                });
            } catch (err) {
                console.error('Wake Lock error:', err);
            }
        }

        async function releaseWakeLock() {
            if (wakeLock) {
                try {
                    await wakeLock.release();
                    wakeLock = null;
                    console.log('Wake Lock manually released');
                } catch (err) {
                    console.error('Wake Lock release error:', err);
                }
            }
        }

        // Re-acquire wake lock when page becomes visible again
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });

        // Media Session for vocabulary modes (Dictionary, Words to Review)
        function setupVocabularyMediaSession(word, mode) {
            if (!('mediaSession' in navigator)) {
                return;
            }

            const modeLabel = mode === 'english' ? 'English Only' : 'English + Russian';
            navigator.mediaSession.metadata = new MediaMetadata({
                title: word,
                artist: `Vocabulary Review - ${modeLabel}`,
                album: 'English Learning',
                artwork: [
                    { src: 'https://vocab.aimediaflow.net/icon-192.png', sizes: '192x192', type: 'image/png' },
                    { src: 'https://vocab.aimediaflow.net/icon-512.png', sizes: '512x512', type: 'image/png' }
                ]
            });

            // Setup basic controls
            navigator.mediaSession.setActionHandler('pause', () => {
                // Stop autoplay
                if (dictAutoplayMode) {
                    stopDictAutoplay();
                } else if (randomAutoplayMode) {
                    stopRandomAutoplay();
                } else if (autoplayMode) {
                    stopAutoplay();
                }
            });

            navigator.mediaSession.setActionHandler('play', null); // Not applicable for vocabulary
            navigator.mediaSession.setActionHandler('seekbackward', null);
            navigator.mediaSession.setActionHandler('seekforward', null);
        }

        function togglePodcastDescription(index) {
            if (expandedPodcastDescriptions.has(index)) {
                expandedPodcastDescriptions.delete(index);
            } else {
                expandedPodcastDescriptions.add(index);
            }
            renderPodcasts();
        }

        async function transcribePodcast(index, audioUrl) {
            if (transcribingPodcasts.has(index) || podcastTranscripts[index]) return;

            // Check if transcript already exists in cache
            const hasTranscriptInCache = podcastTranscripts[audioUrl];

            if (!hasTranscriptInCache) {
                // Ask for confirmation before transcribing
                const confirmed = confirm('Start transcription? This may take 3-5 minutes and will use server resources.');
                if (!confirmed) {
                    return;
                }
            }

            transcribingPodcasts.add(index);
            renderPodcasts();

            try {
                console.log('Starting transcription for podcast:', index);
                const url = TRANSCRIBE_API_URL + '?audioUrl=' + encodeURIComponent(audioUrl) + '&podcastId=' + index;

                const xhr = new XMLHttpRequest();
                xhr.timeout = 600000; // 10 minutes timeout
                xhr.ontimeout = () => {
                    throw new Error('Transcription timeout');
                };
                xhr.onerror = () => {
                    throw new Error('Network error');
                };
                xhr.onload = function() {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            const data = JSON.parse(xhr.responseText);
                            let transcript = data.transcript || 'No transcript available';
                            const fileSizeMB = data.fileSizeMB;

                            // Log file size for debugging
                            if (fileSizeMB) {
                                console.log(`Audio file size: ${fileSizeMB} MB`);
                            }

                            // Parse nested JSON if it's a string
                            let segments = [];
                            if (typeof transcript === 'string' && transcript.startsWith('{')) {
                                try {
                                    // Parse double-escaped JSON: {"data": "{...}"}
                                    const parsed = JSON.parse(transcript);
                                    if (parsed.data && typeof parsed.data === 'string') {
                                        const innerParsed = JSON.parse(parsed.data);
                                        if (innerParsed.segments && Array.isArray(innerParsed.segments)) {
                                            segments = innerParsed.segments;
                                            // Format with timestamps
                                            transcript = segments.map(seg => {
                                                const time = formatTime(seg.start);
                                                return `[${time}] ${seg.text.trim()}`;
                                            }).join('\n\n');
                                        } else if (innerParsed.text) {
                                            transcript = innerParsed.text;
                                        }
                                    }
                                } catch (parseErr) {
                                    console.warn('Could not parse nested JSON:', parseErr);
                                }
                            }

                            podcastTranscripts[index] = transcript;
                            podcastTranscriptSegments[index] = segments;
                            console.log('Transcription complete:', index, 'segments:', segments.length, 'file size:', fileSizeMB, 'MB');
                        } catch (e) {
                            throw new Error('Invalid response: ' + e.message);
                        }
                    } else {
                        throw new Error('HTTP ' + xhr.status);
                    }
                    transcribingPodcasts.delete(index);
                    renderPodcasts();
                    // Also update player page if it's open
                    const playerPage = document.getElementById('podcastPlayerPage');
                    if (playerPage && playerPage.classList.contains('active') && currentPodcastIndex === index) {
                        renderPlayerTranscript();
                    }
                };
                xhr.open('GET', url);
                xhr.send();

            } catch (error) {
                console.error('Transcription error:', error);
                transcribingPodcasts.delete(index);
                alert('Failed to transcribe podcast: ' + error.message);
                renderPodcasts();
            }
        }

        // Find closest element with data-action
        function findActionElement(el) {
            while (el && el !== document.body) {
                if (el.getAttribute && el.getAttribute('data-action')) {
                    return el;
                }
                el = el.parentElement;
            }
            return null;
        }

        // Event delegation
        function onInteraction(e) {
            const target = findActionElement(e.target);
            if (target && handleAction(target, e)) {
                e.preventDefault();
                e.stopPropagation();
            }
        }

        // Use capturing phase for better compatibility
        document.addEventListener('click', function(e) {
            onInteraction(e);
        }, true);

        // Also listen on touchend for Telegram WebView
        let touchMoved = false;
        document.addEventListener('touchstart', function() {
            touchMoved = false;
        }, true);
        document.addEventListener('touchmove', function() {
            touchMoved = true;
        }, true);
        document.addEventListener('touchend', function(e) {
            if (!touchMoved) {
                const target = findActionElement(e.target);
                if (target && handleAction(target)) {
                    e.preventDefault();
                }
            }
        }, true);

        // Load words on start
        loadWords();
    </script>
</body>
</html>
